; MDI2 MIDI DIGITAL INTERFACE;   1/9/93 BY ROBERT TRESCOTT;   ©1993 CUSTOM AUTOMATED ELECTRONICS;;   647180 PROTO EMULATOR;;	5/22/93 rct - added digital proportional servo code;;;******************************************************        CPU  "64180.TBL"		; LOAD 64180 TABLE		HOF  "INT8"				; HEX FORMAT		INCL "647180.INC"		;****************************************************;I/O for 647180 Proto - Starts at 80H;****************************************************TRUE:			EQU	0FFHFALSE:			EQU	0PROTO180:		SET FALSE			; CONDITIONAL ASSY USING EMULATOR OR MCUSEVEN_BIT:		SET FALSEP1DR:			EQU	80HP1DDR:			EQU	81HP2DR:			EQU	82HP2DDR:			EQU	83HP3DR:			EQU	90HP3DDR:			EQU	91HP4DR:			EQU	92HP4DDR:			EQU	93HIF PROTO180	MIDI:			SET FALSE	MONITOR:		EQU 1F00H		; 647180 MONITOR WARM START VECTOR	BTOA:			EQU 1F0CH	CRLF:			EQU 1F03H	PROGSTART:		EQU	08000H		; PROTO STARTING ADDRESS	CHAN_PORT:		EQU P3DR	MODE_PORT:		EQU DRG	CHAN_DDR:		EQU P3DDR	PORTB:			EQU P1DR	PORTC:			EQU P2DR	PORTB_DDR:		EQU P1DDR	PORTC_DDR:		EQU P2DDR	TESTPORT:		EQU P4DR	TESTPORT_DDR:	EQU P4DDR	F_TIME:			EQU 23040	M_TIME:			EQU 2304+F_TIME	R_TIME:			EQU 1536+F_TIME-450	L_TIME:			EQU 3072+F_TIME+450	MULTI:			EQU 19ELSE	MIDI:			SET TRUE	PROGSTART:		EQU	0000H		; MCU STARTING ADDRESS <-----------	CHAN_PORT:		EQU DRF	MODE_PORT:		EQU DRG	CHAN_DDR:		EQU DDRF	PORTB:			EQU ODRC	PORTC:			EQU ODRD	PORTB_DDR:		EQU DDRC	PORTC_DDR:		EQU DDRD	TESTPORT:		EQU ODRB	TESTPORT_DDR:	EQU DDRB	F_TIME:			EQU 18750		; (1/(CLK MHZ/4))/FRAME(15MS)	M_TIME:			EQU 1650+F_TIME	; 1875 AIRTRONICS(1.5MS), 1650 FUTABA(1.52MS)	R_TIME:			EQU 659+F_TIME	; 884 AIRTRONICS(.707MS), 659 FUTABA(.8MS)	MULTI:			EQU 16ENDIRAMSTORAGE:		EQU	0FE00H		; EXTERNAL RAM STORAGE FOR GLOBALSRAMSIZE:		EQU	512			; 512 BYTES OF INTERNAL RAMRXSIZE:     EQU 64INSIZE:     EQU 64NOTEOFF:    EQU 10000000BNOTEON:     EQU 10010000BCONTRL:     EQU 10110000BMAXON:      EQU 00111111B; SETUP DYNAMIC VARIABLE EQUATES FOR STORAGE            ORG RAMSTORAGEBYTE:       EQU 1WORD:       EQU 2LWORD:      EQU 4  MVALID:     DFS BYTEMSTATUS:    DFS BYTE BYTEFLAG:   DFS BYTEMKEY:       DFS BYTEMVEL:       DFS BYTERXEMPTY:    DFS BYTEMWORDH:     DFS BYTEMWORDL:     DFS BYTERXOUT:      DFS BYTERXIN:       DFS BYTETEMPH:      DFS BYTETEMPL:      DFS BYTECLONEB:     DFS BYTECLONEC:     DFS BYTEMODE:       DFS BYTETXSTATUS:   DFS BYTEPXSTATUS:   DFS BYTETXKEY:      DFS BYTETXVEL:      DFS BYTEPREINH:     DFS BYTEPREINL:     DFS BYTENEWINH:     DFS BYTENEWINL:     DFS BYTETEMPINH:    DFS BYTETEMPINL:    DFS BYTESAVEH:      DFS BYTESAVEL:      DFS BYTEFRAMELEV:	DFS BYTEFRC_FLAG:	DFS BYTEPREPOS_1:	DFS BYTEPREPOS_2:	DFS BYTESERPOS_1:	DFS BYTESERPOS_2:	DFS BYTESERSEL1:	DFS BYTESERSEL2:	DFS BYTESERVO_1:	DFS WORDSERVO_2:	DFS WORDSERVAL1:	DFS WORDSERVAL2:	DFS WORDMNOTE:      DFS BYTE * RXSIZE           VAR_END:;****************************************************; Main Program Starts Here;****************************************************;		ORG PROGSTART		; set up interrupt table address;START:	DI					; DISABLE ALL INTERRUPTS        LD DE,INTTBL		; Point to interrupt table        LD A,D 				; Ms table address        LD I,A        OUT0 (IL),E			; Loads table address				LD A, 00000000B		OUT0 (ITC),A		; DISABLE EXTERNAL INTERRUPTS				IM1					; SINGLE CHIP INTERRUPT MODE 1		JP RESET		DFS	256-{{$-START} AND 255}		; Force 256 byte boundaryRESET:	LD SP,RAMSTORAGE+RAMSIZE-1	; INIT STACK POINTER				LD A,00				; NO WAIT STATES		OUT0 (DCNTL),A				IF PROTO180		LD A,0				; SET DATA DIR CONTROL		OUT0 (TESTPORT_DDR),A		OUT0 (CHAN_DDR),A	; SAVE  TO DDR NOW		OUT0 (CHAN_PORT),A	; SAVE  TO DDR NOW ALL INPUTS				LD A,0FFH		OUT0 (TESTPORT),A	; ALL OUTPUTS								LD A,00000100B		; SET PORT CONTROL TO I/O		OUT0 (TESTPORT_DDR),A		OUT0 (CHAN_DDR),A		LD A,0		OUT0 (TESTPORT),A	; ALL LOW OUTPUTS						ELSE		LD A,0		OUT0 (CHAN_DDR),A		OUT0 (TESTPORT),A		LD A,0FFH		OUT0 (TESTPORT_DDR),AENDI		LD HL,RAMSTORAGE	; RAM STARTING ADDRESS		LD B,VAR_END-RAMSTORAGE	; NUMBER OF VARS TO ZERO OUT		LD A,0H				; CLEAR WITH $0'S		CLEAR:  LD (HL),A           ; FILL ZERO PAGE WITH $0'S		INC HL		DJNZ CLEAR			; KEEP LOOPING TILL DONE		LD A,0				; MIDI 10MHZ XTAL 31250 BAUD		OUT0 (CNTLB0),A				OUT0 (STAT0),A		LD (FRAMELEV),A		LD (FRC_FLAG),A				LD A,64				; MIDI SERVO VALUE TO MID POSITION		LD (MVEL),A		LD (SERPOS_1),A				LD (SERPOS_2),A				LD (PREPOS_1),A				LD (PREPOS_2),A						LD BC,M_TIME		; SERVO TIMERS TO MID POSITION		LD (SERVO_1),BC		LD (SERVO_2),BC		LD (SERVAL1),BC		LD (SERVAL2),BC				LD A,01100100B		; ENABLE RECEIVER AND XMITTER		OUT0 (CNTLA0),A		IN0 A,(STAT0)		; CLEAR ANY CHARS FROM RECV REGISTER		        LD A,0FFH           ; SAVE THESE HIGH        LD (MKEY),A        LD (RXEMPTY),A        		LD A,00001000B		OUT0 (STAT0),A        IN0	A,(MODE_PORT)	; GET MIDI CHANNEL        AND 00001111B		; MASK UNUSED BITS        LD (MODE),A			; SAVE NEW DATA		EI					; ENABLE INTERRUPTS				IF PROTO180		LD A,10ENDIMODET1: CP 1        JR NZ,MODET2        JP MODE1MODET2: CP 2        JR NZ,MODET3        JP MODE2MODET3: CP 3        JR NZ,MODET4        JP MODE3MODET4: CP 4        JR NZ,MODET5        JP MODE4MODET5: CP 5        JR NZ,MODET6        JP MODE5MODET6: CP 6        JR NZ,MODET7        JP MODE6MODET7: CP 7        JR NZ,MODET8        JP MODE7MODET8: CP 8		JR NZ,MODET9		JP MODE8MODET9: CP 9        JR NZ,MODETA        JP MODE9MODETA:	CP 10		JR NZ,MODE0 		; DEFAULT TO MODE 0		JP MODE10		; NOTE ON/OFF 16 BITS DECODEDMODE0:	LD BC,0FFFFH		CALL INIT_PIA		LD BC,0				; INITIALIZE PIA PORT PINS		CALL OUT16PMODE0M: CALL HLMIDI			; HANDLE ALL MIDI DATA		CALL HDL16			; HANDLE OUTPUTS		JR MODE0M			; LOOP BACK TO MAIN; CONTROL CHANGE 16 BITS DECODEDMODE1:	LD BC,0FFFFH		CALL INIT_PIA		LD BC,0				; INITIALIZE PIA PORT PINS		CALL OUT16PMODE1M: CALL HLMIDI			; HANDLE ALL MIDI DATA		CALL HCC16			; HANDLE OUTPUTS        JR MODE1M			; LOOP BACK TO MAIN; NOTE ON/OFF 128 BITS ENCODEDMODE2:  LD BC,0FFFFH		CALL INIT_PIA		LD BC,0				; INITIALIZE PIA PORT PINS		CALL OUT16PMODE2M: CALL HLMIDI			; HANDLE ALL MIDI DATA		CALL HDL128			; HANDLE OUTPUTS		JR MODE2M			; LOOP BACK TO MAIN; CONTROL CHANGE 128 BITS ENCODEDMODE3:  LD BC,0FFFFH		CALL INIT_PIA		LD BC,0				; INITIALIZE PIA PORT PINS		CALL OUT16PMODE3M: CALL HLMIDI			; HANDLE ALL MIDI DATA		CALL HCC128			; HANDLE OUTPUTS        JR MODE3M			; LOOP BACK TO MAIN       ; 8 NOTE ON/OFF OUTPUTS + 8 NOTE ON/OFF INPUTS             MODE4:  LD BC,0FF00H		CALL INIT_PIA		LD BC,0				; INITIALIZE PIA PORT PINS		CALL OUT8PMODE4M: CALL HLMIDI		CALL HDL8M4NEXT: LD A,(SAVEH)		LD (TEMPL),A		; RESTORE PREV COUNTER VALUEM4HIGH: CALL IN8HIGH		; READ NEW LOW DATA		LD A,(TEMPL)		; GET COUNTER VALUE		CP 16				; DO WE NEED TO UPDATE THIS		JR Z, M4SAVEH		; IF NOT THEN NEXT		LD A,(TEMPINH)		; SHIFT DATA FOR COMMAND		SRL A		LD (TEMPINH),A		JR C,M4HON			; IF CARRY IS SET THEN NOTE ON DATA		CALL TXNOTEOFF		; ELSE SEND OUT NOTE OFF COMMAND		JR M4HIGH			; KEEP LOOPING FOR MOREM4HON:	CALL TXNOTEON		JR M4HIGH			; KEEP LOOPING FOR MORE DATAM4SAVEH:LD A,(TEMPL)		LD (SAVEH),A		; SAVE FOR LATER		JR MODE4M			; LOOP BACK TO MAIN; 8 CONTROL CHANGE OUTPUTS + 8 CONTROL CHANGE INPUTS             MODE5:  LD BC,0FF00H		CALL INIT_PIA		LD BC,0				; INITIALIZE PIA PORT PINS		CALL OUT8PMODE5M: CALL HLMIDI		CALL HCC8M5NEXT: LD A,(SAVEH)		LD (TEMPL),A		; RESTORE PREV COUNTER VALUEM5HIGH: CALL IN8HIGH		; READ NEW LOW DATA		LD A,(TEMPL)		; GET COUNTER VALUE		CP 16				; DO WE NEED TO UPDATE THIS		JR Z, M5SAVEH		; IF NOT THEN NEXT		LD A,(TEMPINH)		; SHIFT DATA FOR COMMAND		SRL A		LD (TEMPINH),A		JR C,M5HON			; IF CARRY IS SET THEN NOTE ON DATA		CALL TXCTLOFF		; ELSE SEND OUT NOTE OFF COMMAND		JR M5HIGH			; KEEP LOOPING FOR MOREM5HON:  CALL TXCTLON		JR M5HIGH			; KEEP LOOPING FOR MORE DATAM5SAVEH:LD A,(TEMPL)		LD (SAVEH),A		; SAVE FOR LATER		JR MODE5M			; LOOP BACK TO MAIN; 16 NOTE ON/OFF INPUTS             MODE6:  LD BC,0		CALL INIT_PIAMODE6L:	LD A,(SAVEL)		LD (TEMPL),A        M6LOW:  CALL IN8LOW			; READ NEW LOW DATA		LD A,(TEMPL)		; GET COUNTER VALUE		CP 8				; DO WE NEED TO UPDATE THIS		JR Z, M6SAVEL		; IF NOT THEN NEXT		LD A,(TEMPINL)		; SHIFT DATA FOR COMMAND		SRL A		LD (TEMPINL),A		JR C,M6LON			; IF CARRY IS SET THEN NOTE ON DATA		CALL TXNOTEOFF		; ELSE SEND OUT NOTE OFF COMMAND		JR M6LOW 			; KEEP LOOPING FOR MOREM6LON:  CALL TXNOTEON		JR M6LOW			; KEEP LOOPING FOR MORE DATAM6SAVEL: LD A,(TEMPL)		LD (SAVEL),A        M6NEXT: LD A,(SAVEH)        LD (TEMPL),A		; RESTORE PREV COUNTER VALUEM6HIGH: CALL IN8HIGH		; READ NEW LOW DATA		LD A,(TEMPL)		; GET COUNTER VALUE		CP 16				; DO WE NEED TO UPDATE THIS		JR Z, M6SAVEH		; IF NOT THEN NEXT		LD A,(TEMPINH)		; SHIFT DATA FOR COMMAND		SRL A		LD (TEMPINH),A		JR C,M6HON			; IF CARRY IS SET THEN NOTE ON DATA		CALL TXNOTEOFF		; ELSE SEND OUT NOTE OFF COMMAND		JR M6HIGH			; KEEP LOOPING FOR MOREM6HON:  CALL TXNOTEON		JR M6HIGH			; KEEP LOOPING FOR MORE DATAM6SAVEH: LD A,(TEMPL)		LD (SAVEH),A		; SAVE FOR LATERM6NEXT2: JR MODE6L			; LOOP BACK TO MAIN; 16 CONTROL CHANGE INPUTS             MODE7:	LD BC,0		CALL INIT_PIAMODE7L:	LD A,(SAVEL)		LD (TEMPL),A        M7LOW:	CALL IN8LOW			; READ NEW LOW DATA		LD A,(TEMPL)		; GET COUNTER VALUE		CP 8				; DO WE NEED TO UPDATE THIS		JR Z, M7SAVEL		; IF NOT THEN NEXT		LD A,(TEMPINL)		; SHIFT DATA FOR COMMAND		SRL A		LD (TEMPINL),A		JR C, M7LON			; IF CARRY IS SET THEN NOTE ON DATA		CALL TXCTLOFF		; ELSE SEND OUT NOTE OFF COMMAND		JR M7LOW			; KEEP LOOPING FOR MOREM7LON:	CALL TXCTLON        JR M7LOW			; KEEP LOOPING FOR MORE DATAM7SAVEL: LD A,(TEMPL)		LD (SAVEL),A        M7NEXT:	LD A,(SAVEH)		LD (TEMPL),A		; RESTORE PREV COUNTER VALUEM7HIGH: CALL IN8HIGH		; READ NEW LOW DATA		LD A,(TEMPL)		; GET COUNTER VALUE		CP 16				; DO WE NEED TO UPDATE THIS		JR Z, M7SAVEH		; IF NOT THEN NEXT		LD A,(TEMPINH)		; SHIFT DATA FOR COMMAND		SRL A		LD (TEMPINH),A		JR C, M7HON			; IF CARRY IS SET THEN NOTE ON DATA		CALL TXCTLOFF		; ELSE SEND OUT NOTE OFF COMMAND		JR M7HIGH			; KEEP LOOPING FOR MOREM7HON:	CALL TXCTLON		JR M7HIGH			; KEEP LOOPING FOR MORE DATAM7SAVEH: LD A,(TEMPL)		LD (SAVEH),A		; SAVE FOR LATERM7NEXT2: JR MODE7L			; LOOP BACK TO MAIN; 128 NOTE ON/OFF ENCODED INPUTS             MODE8:	LD BC,0		CALL INIT_PIAMODE8L:	CALL RD128			; JUST SIT AND READ		JR MODE8L			; LOOP BACK TO MAIN; 128 CONTROL CHANGE INPUTS             MODE9:	LD BC,0		CALL INIT_PIAMODE9L:	CALL RD128CC		; JUST SIT AND READ		JR MODE9L			; LOOP BACK TO MAIN; DIGITAL PROPORTIONAL SERVO OUTPUT CONTROLMODE10:	LD BC,00FFH		CALL INIT_PIA		LD BC,0		CALL OUT16P				CALL IN16P		LD D,B		LD A,B		AND 00001111B		LD (SERSEL1),A		LD A,D		SRL A		SRL A		SRL A		SRL A				LD (SERSEL2),AMODEAL:	CALL HLMIDI			; GET ANY MIDI DATA		CALL CDS1			; CONTROL SERVO SELECTION		CALL HSC1			; HANDLE SERVO CONTROL 1		CALL HSC2			; HANDLE SERVO CONTROL 2				CALL HDLFRC		JR MODEAL;********************************************************************;   SUBROUTINES FOLLOW;********************************************************************        ; SETUP PORT B AND C DATA DIRECTION;	ENTRY BC REGS WITH DIR DATAINIT_PIA:IF PROTO180		LD A,0		OUT0 (PORTB_DDR),A	; MAKE CONTROL REG DDR PORT		OUT0 (PORTC_DDR),A	; MAKE CONTROL REG DDR PORT		OUT0 (PORTB),B		; SAVE  TO DDR NOW		OUT0 (PORTC),C		; SAVE  TO DDR NOW		LD A,00000100B		; MAKE CONTROL REG I/O PORT		OUT0 (PORTB_DDR),A	; MAKE CONTROL REG DDR PORT		OUT0 (PORTC_DDR),A	; MAKE CONTROL REG DDR PORTELSE		OUT0 (PORTB_DDR),B	; SAVE  TO DDR NOW		OUT0 (PORTC_DDR),C	; SAVE  TO DDR NOWENDI		RET; GET CHANNEL AND BANK DATA INTO A REGCHANBK:        IN0	A,(CHAN_PORT)	; GET MIDI CHANNEL        AND 01111111B		; MASK UNUSED BITSIF PROTO180		LD A,0ENDI				RET; TEST IF DATA AVAIL IS OUR CHANNELTESTCH: LD A,(MVALID)		; FIND OUT IF WE SHOULD DO ANYTHING		TST A				; TICKLE FLAG RESPONSE		JR Z, TCHBYE2		; IF INVALID THEN BYE		LD A,(MWORDH)		; GET MWORD HIGH BYTE		TST A				; TICKLE FLAG RESPONSE		JR NZ, TCHBYE		; PASS IF NO NEW DATA		LD A,(MSTATUS)		; GET CURRENT RUNNING STATUS		AND 00001111B		; LETS TEST FOR CHANNEL FIRST		LD (TEMPL),A        LD HL,TEMPL		CALL CHANBK			; GET OUR CHANNEL		AND 00001111B        CP (HL)				; ARE TWO CHANNELS SAMETCHBYE: RET					; RETURN WITH FLAGS SETTCHBYE2: LD A,0FFH          ; RETURN WITH FLAGS SET		TST A				; TICKLE FLAG RESPONSE		RET; TEST IF DATA IS IN OUR BANK 16 BITTESTBK: LD A,(MKEY)			; GET BANK VALUE		AND 01110000B		LD (TEMPL),A		LD HL,TEMPL		CALL CHANBK		AND 01110000B        CP (HL)				; SAME BANK VALUE		RET;****************************************************************; HANDLE 16 OUTPUTS (NOTE ON/OFF)HDL16:	CALL TESTCH			; IS IT OUR CHANNEL		JR NZ, HDLBYE		; IF NOT THEN IGNORE DATA		CALL TESTBK			; IS IT IN OUR BANK		JR NZ, HDLBYE		; IF NOT THEN BYE BYE				LD A,(MSTATUS)		; GET COMMAND		AND 11110000B		; MASK CHANNEL DATA		CP NOTEOFF			; IS IT A NOTE OFF		JR NZ, HDLON		; IF NOT THEN JUMP        HDLOFF: CALL DECODE			; GET ONE ONLY VALUE		CALL CLR16B			; NOW CLEAR THE BIT		JR HDLOUT			; EXIT AND SET MKEY & MVEL        HDLON:	CP NOTEON		JR NZ, HDLBYE		; IF NOT NOTE ON THEN IGNORE                LD A,(MVEL)			; GET MIDI VELOCITY		TST A        JR Z, HDLOFF		; IF ZERO THEN KEY = OFF        CALL DECODE			; GET ONE ONLY VALUE        CALL SET16B			; NOW SET THE BITHDLOUT: CALL OUT16P        HDLBYE: RET					; EXIT; HANDLE CONTROL CHANGE OUTPUTS 16 BITS CONTROL CHANGEHCC16:  CALL TESTCH			; IS IT OUR CHANNEL		JR NZ, HCCBYE		; IF NOT THEN IGNORE DATA		CALL TESTBK			; IS IT IN OUR BANK		JR NZ, HCCBYE		; IF NOT THEN BYE BYE				LD A,(MSTATUS)		; GET COMMAND		AND 11110000B		; MASK CHANNEL DATA		CP CONTRL			; IS IT A CONTROL CHANGE		JR NZ, HCCBYE		; IF NOT THEN JUMP				LD A,(MVEL)			; GET MIDI VELOCITY				TST A		JR Z, HCCOFF		; IF ZERO THEN KEY = OFF		CP MAXON			; IS IT MAX ON VALUE		JR C, HCCBYE		; IF NOT THEN EXIT		CALL DECODE			; GET ONE ONLY VALUE		CALL SET16B			; NOW SET THE BIT		JR HCCOUTHCCOFF: CALL DECODE			; GET ONE ONLY VALUE        CALL CLR16B			; NOW CLEAR THE BITHCCOUT: CALL OUT16P			; SET PORT NOWHCCBYE: RET; HANDLE 8 OUTPUTS (NOTE ON/OFF)HDL8:	CALL TESTCH			; IS IT OUR CHANNEL		JR NZ, HDL8BYE		; IF NOT THEN IGNORE DATA		CALL TESTBK			; IS IT IN OUR BANK		JR NZ, HDL8BYE		; IF NOT THEN BYE BYE                		LD A,(MSTATUS)		; GET COMMAND		AND 11110000B		; MASK CHANNEL DATA		CP NOTEOFF			; IS IT A NOTE OFF		JR NZ, HDL8ON		; IF NOT THEN JUMP        HDL8OFF: CALL DECODE		; GET ONE ONLY VALUE		CALL CLR8B			; NOW CLEAR THE BIT		JR HDL8OUT			; EXIT AND SET MKEY & MVEL        HDL8ON: CP NOTEON		JR NZ, HDLBYE		; IF NOT NOTE ON THEN IGNORE        		LD A,(MVEL)			; GET MIDI VELOCITY		TST A		JR Z, HDL8OFF		; IF ZERO THEN KEY = OFF		CALL DECODE			; GET ONE ONLY VALUE		CALL SET8B			; NOW SET THE BITHDL8OUT: CALL OUT8P        HDL8BYE: RET				; EXIT; HANDLE CONTROL CHANGE OUTPUTS 8 BITS CONTROL CHANGEHCC8:	CALL TESTCH			; IS IT OUR CHANNEL		JR NZ, HC8BYE		; IF NOT THEN IGNORE DATA		CALL TESTBK			; IS IT IN OUR BANK		JR NZ, HC8BYE		; IF NOT THEN BYE BYE                		LD A,(MSTATUS)		; GET COMMAND		AND 11110000B		; MASK CHANNEL DATA		CP CONTRL			; IS IT A CONTROL CHANGE		JR NZ, HC8BYE		; IF NOT THEN JUMP        		LD A,(MVEL)			; GET MIDI VELOCITY		TST A		JR Z, HC8OFF		; IF ZERO THEN KEY = OFF		CP MAXON			; IS IT MAX ON VALUE		JR NZ, HC8BYE		; IF NOT THEN EXIT		CALL DECODE			; GET ONE ONLY VALUE		CALL SET8B			; NOW SET THE BIT		JR HC8OUTHC8OFF: CALL DECODE			; GET ONE ONLY VALUE        CALL CLR8B			; NOW CLEAR THE BITHC8OUT: CALL OUT8P			; SEND OUT TO PORTHC8BYE: RET        ; HANDLE 128 OUTPUTS (NOTE ON/OFF)HDL128: CALL TESTCH			; IS IT OUR CHANNEL		JR NZ, H128BYE		; IF NOT THEN IGNORE DATA        		LD A,(MSTATUS)		; GET COMMAND		AND 11110000B		; MASK CHANNEL DATA		CP NOTEON			; IS IT A NOTE ON		JR NZ, H128OFF		; IF NOT THEN JUMP		LD A,(MVEL)			; GET MIDI VELOCITY		TST A		JR Z, H128VF		; IF ZERO THEN KEY = OFF		LD A,(MKEY)			; GET MIDI NOTE VALUE		SETT 7,A		LD B,A        JR H128CT        H128OFF: CP NOTEOFF		JR NZ, H128BYE		; IF NOT NOTE ON THEN IGNORE		 H128VF: LD A,(MKEY)			; GET MIDI NOTE VALUE		RES 7,A				; CLEAR UPPER DATA BIT		LD B,AH128CT: LD A,(MVEL)			; GET VELOCITY DATA		RES 7,A				; KEEP LATCH DISABLED		LD C,A		CALL OUT16P		LD A,80H			; SET BIT 7 PORT C		LD (TEMPH),A        LD A,0				; LEAVE OTHER PORT ALONE		LD (TEMPL),A		CALL SET16B		CALL OUT16P			; SEND OUT TO PORT NOW         CALL CLR16B			; USE SAME DATA TO CLEAR BIT 7		CALL OUT16P			; SEND DATA TO PORT NOWH128BYE: RET                        ; HANDLE 128 OUTPUTS (CONTROL CHANGE)HCC128: CALL TESTCH			; IS IT OUR CHANNEL		JR NZ, H128BYE		; IF NOT THEN IGNORE DATA        		LD A,(MSTATUS)		; GET COMMAND		AND 11110000B		; MASK CHANNEL DATA		CP CONTRL			; IS IT A CONTROL CHANGE		JR NZ, H128BYE		; IF NOT THEN BYE		LD A,(MVEL)			; GET MIDI VELOCITY		TST A		JR Z, H128VF		; IF ZERO THEN KEY = OFF		LD A,(MKEY)			; GET MIDI NOTE VALUE		SETT 7,A			; SET UPPER DATA BIT FOR CTRL ON		LD B,A		JP H128CT        ; HANDLE SERVO CHANNEL DATA;CDS1:	CALL TESTCH			; IS IT OUR CHANNEL		RET NZ				; IF NOT THEN IGNORE DATA		CALL TESTBK			; IS IT IN OUR BANK		RET NZ				; IF NOT THEN BYE BYE		LD A,(MSTATUS)		; GET COMMAND		AND 11110000B		; MASK CHANNEL DATA		CP CONTRL			; IS IT A CONTROL CHANGE		RET NZ				; IF NOT THEN BYE						LD A,(MKEY)			; GET KEY VALUE		AND 00001111B				LD HL,SERSEL1		CP (HL)				; IS IT SERVO 1		JR Z,CDSEL1				LD HL,SERSEL2		CP (HL)				; OR SERVO 2		JR Z,CDSEL2		RET					; EXIT IF NONECDSEL1:	LD HL,PREPOS_1		; GET PREVIOUS MIDI POSITION		LD A,(MVEL)			; GET VELOCITY INFO		SBC A,(HL)		RET Z				; RETURN IF SAME VALUE		BIT 7,A				; TEST DIRECTION BIT		JR Z,DIR1		LD A,(MVEL)			; GET NEW VALUE		LD (PREPOS_1),A		; SAVE FOR LATER		CALL CALC_POS		LD (SERVAL1),HL		; SAVE FINAL SERVO POSITION		INC A		CALL CALC_POS		LD (SERVO_1),HL		; SAVE THIS SERVO POSITION		RETDIR1:	LD A,(MVEL)			; GET NEW VALUE		LD (PREPOS_1),A		; SAVE FOR LATER		CALL CALC_POS		LD (SERVAL1),HL		; SAVE FINAL SERVO POSITION		DEC A				; MINUS 1		CALL CALC_POS		LD (SERVO_1),HL		; SAVE THIS SERVO POSITION		RET				CDSEL2:	LD HL,PREPOS_2		; GET PREVIOUS MIDI POSITION		LD A,(MVEL)			; GET VELOCITY INFO		SBC A,(HL)		RET Z				; RETURN IF SAME VALUE		BIT 7,A				; TEST DIRECTION BIT		JR Z,DIR2		LD A,(MVEL)			; GET NEW VALUE		LD (PREPOS_2),A		; SAVE FOR LATER		CALL CALC_POS		LD (SERVAL2),HL		; SAVE FINAL SERVO POSITION		INC A		CALL CALC_POS		LD (SERVO_2),HL		; SAVE THIS SERVO POSITION		RETDIR2:	LD A,(MVEL)			; GET NEW VALUE		LD (PREPOS_2),A		; SAVE FOR LATER		CALL CALC_POS		LD (SERVAL2),HL		; SAVE FINAL SERVO POSITION		DEC A				; MINUS 1		CALL CALC_POS		LD (SERVO_2),HL		; SAVE THIS SERVO POSITION		RET; CALCULATE ABSOLUTE MIDI POSITION;	ENTRY: 	A - MIDI VELOCITY (POSITION) DATA;	RETURN:	HL - RESULT OF CALCULATION (16 BIT FOR FRC TIMER);CALC_POS:		LD C,A				; POSITION INTO C REG		LD B,MULTI			; MULTIPLIER		MLT BC				; B*C -> BC		LD HL,R_TIME		; GET MINIMUM PULSE WAVE		ADD HL,BC			; ADD TO RESULT		RET; HANDLE SERVO CONTROL #1;HSC1:	IN0 A,(T2CSR2)		; GET COMPARE FLAG STATUS		AND 01000000B		; READ OUTPUT COMPARE FLAG 1		RET Z				; IF NONE THEN BYE		LD HL,FRAMELEV		; GET FRAME LEVEL STATUS		BIT 0,(HL)		JR Z, FL1LOWFL1HI:	RES 0,(HL) 			; FRAME LEVEL WAS HIGH NOW MAKE IT LOW										LD HL,FRC_FLAG		RES 0,(HL)			; CLEAR FRC SEMAPHORE THEN RETURN		RETFL1LOW:	SETT 0,(HL)			; FRAME LEVEL WAS LOW NOW MAKE IT HIGH		IN0 A,(T2CSR1)		; GET OUT LEVEL FROM REGISTER		RES 0,A		OUT0 (T2CSR1),A		; CLEAR AND SAVE NEXT HI LEVEL						LD BC,(SERVO_1)		; GET FRAME TIME FOR NEXT LEVEL		OUT0 (T2OCR1H),B		OUT0 (T2OCR1L),C		RET; HANDLE SERVO CONTROL #2;HSC2:	IN0 A,(T2CSR2)		; GET COMPARE FLAG STATUS		AND 00100000B		; READ OUTPUT COMPARE FLAG 2		RET Z				; IF NONE THEN BYE		LD HL,FRAMELEV		; GET FRAME LEVEL STATUS		BIT 1,(HL)		JR Z, FL2LOWFL2HI:	RES 1,(HL) 			; FRAME LEVEL WAS HIGH NOW MAKE IT LOW										LD HL,FRC_FLAG		RES 1,(HL)			; CLEAR FRC SEMAPHORE THEN RETURN		JR FL2XITFL2LOW:	SETT 1,(HL)			; FRAME LEVEL WAS LOW NOW MAKE IT HIGH		IN0 A,(T2CSR2)		; GET OUT LEVEL FROM REGISTER		RES 2,A		OUT0 (T2CSR2),A		; CLEAR AND SAVE NEXT HI LEVEL						LD BC,(SERVO_2)		; GET FRAME TIME FOR NEXT LEVEL		OUT0 (T2OCR2H),B		OUT0 (T2OCR2L),CFL2XIT:	RET; CLEAR FREE RUNNING COUNTER IF FRC_FLAG SEMAPHORE IS CLEARHDLFRC:		LD A,(FRC_FLAG)		; GET FLAG STATUS		TST A		RET NZ				; RETURN IF NOT ZERO				LD A,00000011B		; SET SEMAPHORE FLAGS		LD (FRC_FLAG),A		LD BC,0000H			; CLEAR FRC		OUT0 (T2FRCH),B		OUT0 (T2FRCL),C				IN0 A,(T2CSR1)		; GET OUT LEVEL FROM REGISTER		SETT 0,A		OUT0 (T2CSR1),A		; CLEAR AND SAVE NEXT HI LEVEL		IN0 A,(T2CSR2)		; GET OUT LEVEL FROM REGISTER		SETT 2,A		OUT0 (T2CSR2),A		; CLEAR AND SAVE NEXT HI LEVEL		LD BC,F_TIME		; GET FRAME TIME FOR NEXT LEVEL		OUT0 (T2OCR1H),B		OUT0 (T2OCR1L),C		OUT0 (T2OCR2H),B		OUT0 (T2OCR2L),C						LD A,0		LD (FRAMELEV),A		; BOTH FRAME LEVELS LOWIF SEVEN_BIT		LD HL,(SERVAL1)		LD (SERVO_1),HL		LD HL,(SERVAL2)		LD (SERVO_2),HLELSE		LD HL,(SERVO_1)		; SMOOTH BOTH SERVOS		LD BC,(SERVAL1)		SBC HL,BC		JR Z,NSERVO		JR C,FRD1		LD HL,(SERVO_1)		DEC HL		LD (SERVO_1),HL		JR NSERVO				FRD1:	LD HL,(SERVO_1)		INC HL		LD (SERVO_1),HLNSERVO:	LD HL,(SERVO_2)		LD BC,(SERVAL2)		SBC HL,BC		RET Z		JR C,FRD2		LD HL,(SERVO_2)		DEC HL		LD (SERVO_2),HL		RET				FRD2:	LD HL,(SERVO_2)		INC HL		LD (SERVO_2),HLENDI		RET					; RETURN WHEN DONE				; DECODE MIDI WORD TO 'ONE ONLY' FORMAT;  ENTRY: MKEY = MIDI BYTE;  RETURNS: TEMPX HAS 'ONE ONLY' VALUE IN IT;DECODE: LD A,0				; INITIALIZE TEMPX		LD (TEMPH),A		LD (TEMPL),A		LD A,(MKEY)			; GET KEY VALUE		AND 00001111B		; MASK UNUSED BITS		LD D,A				; PLACE MKEY COUNT INTO INDEX		INC D				; ADD 1 FOR ZERO TEST		SCF					; SET CARY FLAG FOR ROTATEDLOOP1: LD HL,TEMPL		RL (HL)				; ROTATE TEMPL TO LEFT		JR C, DLOOP2		; IF CARRY IS SET THEN GOTO NEXT BYTE		DEC D		JR Z, DEDONE		; IF X COUNTS TO ZERO THEN DONE		JR DLOOP1DLOOP2: LD HL,TEMPH		RL (HL)				; ROTATE NEXT BYTE		DEC D		JR NZ, DLOOP2 DEDONE: RET; SET PORT BIT IN OUTPUT PIA;  ENTER: TEMPX = DATA TO OUTPUTSET16B: LD A,(CLONEC)		; GET PREVIOUS DATA		LD HL,TEMPH		OR (HL)				; SET NEW DATA BIT (HIGHBYTE)		LD C,A				; SAVE IN YSET8B:	LD A,(CLONEB)		; GET PREVIOUS DATA		LD HL,TEMPL		OR (HL)				; SET NEW DATA BIT (LOWBYTE)		LD B,A				; SAVE IN X		RET; CLEAR PORT BIT IN OUTPUT PIA;  ENTER: TEMPD = DATA TO OUTPUTCLR16B: LD A,(CLONEC)		; GET PREVIOUS DATA		LD HL,TEMPH		XOR 0FFH			; GET NOT DATA		OR (HL)				; SET NEW DATA BIT (HIGHBYTE)		XOR 0FFH		LD C,A				; SAVE IN CCLR8B:  LD A,(CLONEB)		; GET PREVIOUS DATA		LD HL,TEMPL		XOR 0FFH        OR (HL)				; SET NEW DATA BIT (LOWBYTE)        XOR 0FFH		LD B,A        RET; OUTPUT 16 BIT WORD TO PIA1 PORT;  ENTER: BC REG = DATA TO OUTPUT;OUT16P: LD A,C				; PLACE C INTO ACCUM		LD (CLONEC),A		; SAVE NEW CLONE DATA;		XOR 0FFH			; MAKE ACTIVE LOW		OUT0 (PORTC),A		; WRITE OUT TO PORT        OUT8P:	LD A,B		LD (CLONEB),A;		XOR 0FFH			; MAKE ACTIVE LOW		OUT0 (PORTB),A		; WRITE OUT TO PORT		RET; INPUT 16 BIT WORD FROM PIA1 PORT;  RETURN BC REGIN16P:	IN0 A,(PORTC);		XOR 0FFH			; (NEGATIVE LOGIC)		LD C,A				IN0 A,(PORTB);		XOR 0FFH			; (NEGATIVE LOGIC)		LD B,A		RET; READ/UPDATE 8 BIT LOW REGISTER RECURSIVE ROUTINE        IN8LOW: LD A,(TEMPL)		; GET CURRENT COUNT		CP 8		JR NZ, IN8LCT		CALL IN16P			; GET CURRENT PORT DATA		LD A,B				; B HAS PORT VALUE		LD (TEMPINL),A		; SAVE FOR LATER SHIFTING		LD (NEWINL),A		LD HL,PREINL		XOR (HL)			; COMPARE TO LAST READING		JR Z, IN8BYE		; IF SAME THEN BYE        		LD (HL),A			; SAVE FOR LATER SHIFTING		LD A,0FFH			; ALLOWS START FROM ZERO AFTER INSHIFT		LD (TEMPL),A		; CLEAR INCOUNT IN8LCT: INC A				; ADD 1 TO INPUT COUNTER		LD (TEMPL),A		; PUT TEMPL INTO ACCUM		CP 8		JR Z,IN8PAS			; IF TEMPL = 8 THEN WE ARE DONEIN8LOOP: LD HL,PREINL		SRL (HL)			; SHIFT THE EOR DATA FOR TESTING BITS		JR C,IN8BYE			; IF CARRY SET THEN NEW BIT DATA		LD HL,TEMPINL		SRL (HL)			; KEEP IN SYNC WITH PREINL		JR IN8LCT			; KEEP GOING TILL NEW DATA OR TEMPL=8IN8PAS: LD A,(NEWINL)		; THIS IS THE END OF THE ROUTINE        LD (PREINL),A		; SO PREPARE PREINL FOR NEXT READINGIN8BYE: RET					; RETURN WITH POSSIBLE DATA IF TEMPL<>8; READ/UPDATE 8 BIT HIGH REGISTER RECURSIVE ROUTINE        IN8HIGH:		LD A,(TEMPL)		; GET CURRENT COUNT		CP 16		JR NZ,IN8HCT		CALL IN16P			; GET CURRENT PORT DATA		LD A,C				; C REG HAS HIGH PORT VALUE		LD (TEMPINH),A		; SAVE FOR LATER SHIFTING		LD (NEWINH),A				LD HL,PREINH		XOR (HL)			; COMPARE TO LAST READING		RET Z				; IF SAME THEN BYE        		LD (HL),A			; SAVE FOR LATER SHIFTING		LD A,7				; ALLOWS START FROM ZERO AFTER INSHIFTIN8HCT: INC A				; ADD 1 TO INPUT COUNTER		LD (TEMPL),A		; PUT TEMPL INTO ACCUM		CP 16		JR Z, IN8HPAS		; IF TEMPL = 16 THEN WE ARE DONEIN8HLOOP:		LD HL,PREINH		SRL (HL)			; SHIFT THE EOR DATA FOR TESTING BITS		JR C,IN8BYE			; IF CARRY SET THEN NEW BIT DATA		LD HL,TEMPINH		SRL (HL)			; KEEP IN SYNC WITH PREINL		JR IN8HCT			; KEEP GOING TILL NEW DATA OR TEMPL=16IN8HPAS: LD A,(NEWINH)		; THIS IS THE END OF THE ROUTINE		LD (PREINH),A		; SO PREPARE PREINL FOR NEXT READINGIN8HBYE: RET				; RETURN WITH POSSIBLE DATA IF TEMPL<>16; HANDLE 128 NOTE ON/OFF ENCODED INPUTSRD128:	CALL IN16P			; GET PIA INPUTS INTO BC		LD A,C		LD (NEWINH),A		; SAVE FOR LATER		LD A,B		LD (NEWINL),A		; SAVE FOR LATER		BIT 7,C				; TEST BIT 7		RET Z				; IF CLEAR THEN BYE BYE				BIT 7,B		JR Z,RD128OFF		; IF CLEAR THEN ITS NOTE OFF                		CALL CHANBK			; GET OUR CHANNEL		AND 00001111B		; MASK OUT BANK		OR NOTEON			; SET OUR NOTE ON STATUS		JR RDNOT128			; SAME ROUTINE FROM HERERD128OFF:        		CALL CHANBK			; GET OUR CHANNEL		AND 00001111B		; MASK OUT BANK		OR NOTEOFF			; SET OUR NOTE OFF STATUSRDNOT128: 		LD (TXSTATUS),A		; SAVE RESULT INTO STATUS		LD A,(NEWINH)		; GET PREV DATA		AND 01111111B		LD (TXVEL),A		; SAVE VELOCITY		LD A,(NEWINL)		AND 01111111B		LD (TXKEY),A		; SAVE RESULT INTO MIDI KEY VALUE		CALL TXMIDI			; SEND IT OUT NOWRD128DEB:		CALL IN16P			; GET PIA INPUTS INTO BC		BIT 7,C				; TEST BIT 7		JR NZ,RD128DEB		; DEBOUNCE STROBE LINE		RD128BYE:		RET        ; HANDLE 128 NOTE CONTROL CHANGE ENCODED INPUTSRD128CC:		CALL IN16P			; GET PIA INPUTS INTO BC		LD A,C		LD (NEWINH),A		; SAVE FOR LATER		LD A,B		LD (NEWINL),A		; SAVE FOR LATER		BIT 7,C				; TEST BIT 7		RET Z				; IF CLEAR THEN BYE BYE                		CALL CHANBK		; GET OUR CHANNEL		AND 00001111B		; MASK OUT BANK		OR CONTRL			; SET OUR CONTROL CHANGE STATUS		JR RDNOT128; TRANSMITT CONTROL CHANGE ON DATATXCTLON:		CALL CHANBK		; GET OUR CHANNEL		AND 00001111B		; MASK OUT BANK		OR CONTRL			; SET OUR NOTE ON STATUS		LD (TXSTATUS),A		; SAVE RESULT INTO STATUS        		CALL CHANBK		; NOW GET OUR BANK #		AND 01110000B		; MASK OUT CHANNEL		LD HL,TEMPL		OR (HL)				; GET CURRENT COUNT		LD (TXKEY),A		; SAVE RESULT INTO MIDI KEY VALUE        		LD A, MAXON			; DEFAULT VELOCITY		LD (TXVEL),A		CALL TXMIDI			; SEND IT ALL NOW        		RET        ; TRANSMITT CONTROL CHANGE OFF DATATXCTLOFF:		CALL CHANBK			; GET OUR CHANNEL		AND 00001111B		; MASK OUT BANK		OR CONTRL			; SET OUR NOTE ON STATUS		LD (TXSTATUS),A		; SAVE RESULT INTO STATUS        		CALL CHANBK			; NOW GET OUR BANK #		AND 01110000B		; MASK OUT CHANNEL		LD HL,TEMPL		OR (HL)				; GET CURRENT COUNT		LD (TXKEY),A		; SAVE RESULT INTO MIDI KEY VALUE        		LD A, 0				; 0 VELOCITY		LD (TXVEL),A		CALL TXMIDI			; SEND IT ALL NOW        		RET                ; TRANSMITT NOTE ON DATATXNOTEON:		CALL CHANBK			; GET OUR CHANNEL		AND 00001111B		; MASK OUT BANK		OR NOTEON			; SET OUR NOTE ON STATUS		JR TXNOTV			; SAME ROUTINE FROM HERE; TRANSMITT NOTE OFF DATATXNOTEOFF:        CALL CHANBK			; GET OUR CHANNEL		AND 00001111B		; MASK OUT BANK		OR NOTEOFF			; SET OUR NOTE OFF STATUSTXNOTV: LD (TXSTATUS),A		; SAVE RESULT INTO STATUS        		CALL CHANBK			; NOW GET OUR BANK #		AND 01110000B		; MASK OUT CHANNEL		LD HL,TEMPL		OR (HL)				; GET CURRENT COUNT		LD (TXKEY),A		; SAVE RESULT INTO MIDI KEY VALUE        		LD A, 65			; DEFAULT VELOCITY		LD (TXVEL),A		CALL TXMIDI          ; SEND IT ALL NOW        		RET; TRANSMIT MIDI DATA STREAM;  ENTRY: A = MIDI DATA TO SENDTXDATA: IF MIDI			IN0 C,(STAT0)		; GET STATUS REGISTER		BIT 1,C				; XMIT BUFFER EMPTY		JR Z, TXDATA		OUT0 (TDR0),A		; XMIT DATA		RETELSE		CALL BTOA		RETENDI; SEND ALL MIDI COMMANDSTXMIDI: LD A,(TXSTATUS)		; CHECK CURRENT STATUS 		CALL TXDATA			; NOW SEND IT OUTTXM1:   LD A,(TXKEY)		; SEND OUT MIDI KEY VALUE		CALL TXDATA		LD A,(TXVEL)		CALL TXDATA			; SEND OUT VELOCITYIF MIDI		RETELSE		CALL CRLF		RETENDI; HANDLE RECVD MIDI BYTE;HLMIDI: LD A,0		LD (MVALID),A		; MAKE MIDI INVALID TO START		CALL RXMIDI			; GET NEXT BYTE IF ANY        		LD A,(MWORDH)		; GET HIGH MIDI BYTE		TST A		JR NZ, HLMBYE		; SAY BYE IF NOT VALID				LD A,(MWORDL)		; GET MIDI WORD DATA		CP 0F8H		RET NC				; EXIT IF > REAL TIME OR EMPTY		CP 0F7H		RET Z						CP 080H		JR C,DATA1			; IF < $80 THEN ITS DATA ELSE STATUS		LD (MSTATUS),A		; SAVE MIDI BYTE IN STATUS		LD A,0		LD (BYTEFLAG),A		; CLEAR OUT THIRDBYTE FLAG        HLMBYE: RET					; EXIT AND IGNOREDATA1:  LD A,(BYTEFLAG)		; GET THIRD BYTE STATUS		TST A		JR Z, NOT3RD		; IF CLEAR THEN ITS NOT THIRD BYTE        		LD A,0		LD (BYTEFLAG),A		; CLEAR THIRD BYTE FLAG		LD A,(MWORDL)		; XFER TO ACCUM		LD (MVEL),A			; 3RD BYTE IS VELOCITY...SAVE NOW		LD A,0FFH 		LD (MVALID),A		; ENABLE MIDI CONTROL NOW		RET					; EXITNOT3RD: LD A,(MSTATUS)		TST A		JR Z, HLMBYE		; IF STATUS IS CLR THEN EXIT		CP 0C0H		JR C,ST3RD			; SAVE NEW DATA		LD A,0		LD (MSTATUS),A		; CLEAR RUNNING STATUS		RET					; IGNORE ANYTHING ELSE        ST3RD:  LD A,0FFH			; SET THIRD BYTE ENABLE FLAG		LD (BYTEFLAG),A		LD A,(MWORDL)		; XFER TO ACCUM		LD (MKEY),A			; SAVE MIDI KEY VALUE		RET        ; GET NEXT MIDI BYTE FROM BUFFER;RXMIDI: LD A,(RXEMPTY)		TST A        JR Z, MLOOP1        LD A,0FFH        LD (MWORDH),A        LD (MWORDL),A        JR RXEXIT        MLOOP1: LD A,0				; DISABLE FURTHER RECV INTERRUPTS		OUT0 (STAT0),A		IN0 A,(STAT0)		; CLEAR ANY RECV FLAGS        LD HL,MNOTE			; START OF MIDI QUEUE		LD A,(RXOUT)		; GET OFFSET VALUE		ADD A,L				; ADD MNOTE LOW TO OFFSET		LD L,A				; SAVE NEW HL VALUE		LD A,(HL)			; GET NEXT DATA BYTE				LD (MWORDL),A		; SAVE AS A WORD FOR RETURN		LD A,0		LD (MWORDH),A		; CLEAR HIGH BYTE        		LD A,(RXOUT)		; GET NEXT BYTE POSITION        INC A		CP RXSIZE			; COMPARE WITH LOW BYTE OF RXOUT WORD        JR NZ, MLOOP2        		LD A,0MLOOP2: LD (RXOUT),A		LD HL,RXIN        CP (HL)				; IS QUEUE EMPTY		JR NZ, RXEXIT        		LD A,0FFH			; IF EMPTY, SET FLAG		LD (RXEMPTY),ARXEXIT: LD A,00001000B		OUT0 (STAT0),A		; REENABLE RECV INTERRUPTS        RET;********************************************************************; RECEIVE NOTE INTERRUPT ROUTINE;********************************************************************IRQ2:   PUSH AF		PUSH HL				IN0 A,(STAT0)		; CLEAR STATUS FLAGS		OUT0 (TESTPORT),A		BIT 7,A		JR Z,IEXT			; IF RECV FLAG NOT SET THEN BYE		LD A,0		OUT0 (STAT0),A		; DISABLE RECV INTERRUPTS		LD HL,MNOTE			; START OF MIDI QUEUE		LD A,(RXIN)			; GET OFFSET VALUE		ADD A,L				; ADD MNOTE LOW TO OFFSET		LD L,A				; SAVE NEW HL VALUE				IN0 A,(RDR0)		; GET REC DATA		LD (HL),A			; SAVE GOOD MIDI NOTE				LD A,0		LD (RXEMPTY),A		; RESET RX QUEUE EMPTY FLAG                LD A,(RXIN)		INC A		CP RXSIZE			; IS IT MAX SIZE		JR NZ, MDONE		LD A,0				; IF MAX THEN RECYCLEMDONE:  LD (RXIN),AIEXT:	LD A,01100100B		; ENABLE RECEIVER AND XMITTER		OUT0 (CNTLA0),A		LD A,00001000B		OUT0 (STAT0),A		; ENABLE RECV INTERRUPTS		LD A,0		OUT0 (TESTPORT),A		POP HL		POP AF				UNDEF:	EI					; REENABLE IRQ'S		RETI;********************************************************************		;****************  TABLES BEGIN HERE  *******************************;********************************************************************;; INTERNAL INTERRUPTS AND VECTORS;TABLES:	DFS	256-{{$-START} AND 255}		; Force 256 byte boundaryINTTBL: DWL    	UNDEF		; INT1        DWL    	UNDEF		; INT2        DWL    	UNDEF		; PRT 0        DWL    	UNDEF		; PRT 1        DWL    	UNDEF		; DMAC 0        DWL    	UNDEF		; DMAC 1        DWL    	UNDEF		; CSI/O        DWL    	IRQ2		; ASCI 0        DWL    	UNDEF		; ASCI 1        DWL    	UNDEF		; INPUT CAPTURE        DWL    	UNDEF		; OUTPUT COMPARE        DWL    	UNDEF		; TIMER OVERFLOWEND