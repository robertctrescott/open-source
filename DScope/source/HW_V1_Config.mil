_GPIO_Configure:
  begin   (midx: 0)
//HW_V1_Config.c,12 :: 		void GPIO_Configure(void)
_GPIO_Configure:
  begin   (midx: 0)
//HW_V1_Config.c,14 :: 		IOPAEN_bit = 1;     // !!!!!!!! VERY IMPORTANT TO ACTIVATE THE APB2 PERIPHERAL CLOCK ENABLES FIRST  !!!!!!!!!!!
	R2 <1> <- 1   (midx: 0)
	R0 <4> <- addr(IOPAEN_bit)   (midx: 0)
	[R0] <0> <- R2   (midx: 0)
//HW_V1_Config.c,23 :: 		+------------ Nib7  KR    Pull up input */
	R1 <4> <- 2290647168   (midx: 0)
	R0 <4> <- addr(GPIOA_CRL)   (midx: 0)
	[R0] <4> <- R1   (midx: 0)
//HW_V1_Config.c,32 :: 		+------------ Nib15 TDI   Pull up input*/
	R1 <4> <- 2290370699   (midx: 0)
	R0 <4> <- addr(GPIOA_CRH)   (midx: 0)
	[R0] <4> <- R1   (midx: 0)
//HW_V1_Config.c,33 :: 		GPIOA_ODR = 0x0FFFF;
	R1 <4> <- 65535   (midx: 0)
	R0 <4> <- addr(GPIOA_ODR)   (midx: 0)
	[R0] <4> <- R1   (midx: 0)
//HW_V1_Config.c,35 :: 		IOPBEN_bit = 1;
	R0 <4> <- addr(IOPBEN_bit)   (midx: 0)
	[R0] <0> <- R2   (midx: 0)
//HW_V1_Config.c,44 :: 		+------------ Nib7  NC    Pull up input  */
	R1 <4> <- 2290648081   (midx: 0)
	R0 <4> <- addr(GPIOB_CRL)   (midx: 0)
	[R0] <4> <- R1   (midx: 0)
//HW_V1_Config.c,53 :: 		+------------ Nib15 MOSI  Alternate output*/
	R1 <4> <- 3148985480   (midx: 0)
	R0 <4> <- addr(GPIOB_CRH)   (midx: 0)
	[R0] <4> <- R1   (midx: 0)
//HW_V1_Config.c,54 :: 		GPIOB_ODR = 0x0FFFF;
	R1 <4> <- 65535   (midx: 0)
	R0 <4> <- addr(GPIOB_ODR)   (midx: 0)
	[R0] <4> <- R1   (midx: 0)
//HW_V1_Config.c,56 :: 		IOPCEN_bit = 1;
	R0 <4> <- addr(IOPCEN_bit)   (midx: 0)
	[R0] <0> <- R2   (midx: 0)
//HW_V1_Config.c,65 :: 		+------------ Nib7  NC    Pull up input */
	R1 <4> <- 2215741569   (midx: 0)
	R0 <4> <- addr(GPIOC_CRL)   (midx: 0)
	[R0] <4> <- R1   (midx: 0)
//HW_V1_Config.c,74 :: 		+------------ Nib15 NC    Pull up input*/
	R1 <4> <- 2290649220   (midx: 0)
	R0 <4> <- addr(GPIOC_CRH)   (midx: 0)
	[R0] <4> <- R1   (midx: 0)
//HW_V1_Config.c,75 :: 		GPIOC_ODR = 0x0FFF0;
	R1 <4> <- 65520   (midx: 0)
	R0 <4> <- addr(GPIOC_ODR)   (midx: 0)
	[R0] <4> <- R1   (midx: 0)
//HW_V1_Config.c,77 :: 		IOPDEN_bit = 1;
	R0 <4> <- addr(IOPDEN_bit)   (midx: 0)
	[R0] <0> <- R2   (midx: 0)
//HW_V1_Config.c,86 :: 		+------------ Nib7  nCS   Hight speed output*/
	R1 <4> <- 942901304   (midx: 0)
	R0 <4> <- addr(GPIOD_CRL)   (midx: 0)
	[R0] <4> <- R1   (midx: 0)
//HW_V1_Config.c,95 :: 		+------------ Nib15 NC    Pull up input*/
	R1 <4> <- 2290845828   (midx: 0)
	R0 <4> <- addr(GPIOD_CRH)   (midx: 0)
	[R0] <4> <- R1   (midx: 0)
//HW_V1_Config.c,96 :: 		GPIOD_ODR = 0x0FF7F;
	R1 <4> <- 65407   (midx: 0)
	R0 <4> <- addr(GPIOD_ODR)   (midx: 0)
	[R0] <4> <- R1   (midx: 0)
//HW_V1_Config.c,98 :: 		IOPEEN_bit = 1;
	R0 <4> <- addr(IOPEEN_bit)   (midx: 0)
	[R0] <0> <- R2   (midx: 0)
//HW_V1_Config.c,99 :: 		GPIOE_CRL = 0x33333333;   //Bit0-7  Hight speed output£¨LCD_DB0-7 £©
	R1 <4> <- 858993459   (midx: 0)
	R0 <4> <- addr(GPIOE_CRL)   (midx: 0)
	[R0] <4> <- R1   (midx: 0)
//HW_V1_Config.c,100 :: 		GPIOE_CRH = 0x33333333;   //Bit8-15 Hight speed output£¨LCD_DB8-15£©
	R1 <4> <- 858993459   (midx: 0)
	R0 <4> <- addr(GPIOE_CRH)   (midx: 0)
	[R0] <4> <- R1   (midx: 0)
//HW_V1_Config.c,102 :: 		AFIOEN_bit = 1;
	R0 <4> <- addr(AFIOEN_bit)   (midx: 0)
	[R0] <0> <- R2   (midx: 0)
//HW_V1_Config.c,107 :: 		++++--------- Reset value */
	R1 <4> <- 4608   (midx: 0)
	R0 <4> <- addr(AFIO_MAPR)   (midx: 0)
	[R0] <4> <- R1   (midx: 0)
  end
   (midx: 0)
_InitUART1:
  begin   (midx: 0)
//HW_V1_Config.c,110 :: 		void InitUART1(void)
_InitUART1:
  begin   (midx: 0)
//HW_V1_Config.c,113 :: 		UART1_Init_Advanced(19200,_UART_8_BIT_DATA,_UART_NOPARITY,_UART_ONE_STOPBIT,&_GPIO_MODULE_USART1_PA9_10); // simple uart
	R0 <4> <- #__GPIO_MODULE_USART1_PA9_10   (midx: 0)
	FARG_UART1_Init_Advanced_module <4> <- PUSH(R0)   (midx: 0)
	R3 <2> <- 0   (midx: 0)
	R2 <2> <- 0   (midx: 0)
	R1 <2> <- 0   (midx: 0)
	R0 <4> <- 19200   (midx: 0)
	CALL _UART1_Init_Advanced   (midx: 0)
//HW_V1_Config.c,114 :: 		NVIC_IntEnable(IVT_INT_USART1);
	R0 <4> <- 53   (midx: 0)
	CALL _NVIC_IntEnable   (midx: 0)
//HW_V1_Config.c,115 :: 		TCIE_USART1_CR1_bit = 0;        // no interrupts with xmit
	R2 <1> <- 0   (midx: 0)
	R0 <4> <- addr(TCIE_USART1_CR1_bit)   (midx: 0)
	[R0] <0> <- R2   (midx: 0)
//HW_V1_Config.c,116 :: 		UE_bit = 1;                     // enable USART1
	R1 <1> <- 1   (midx: 0)
	R0 <4> <- addr(UE_bit)   (midx: 0)
	[R0] <0> <- R1   (midx: 0)
//HW_V1_Config.c,117 :: 		RE_bit = 1;                     // receiver 1 enable
	R0 <4> <- addr(RE_bit)   (midx: 0)
	[R0] <0> <- R1   (midx: 0)
//HW_V1_Config.c,118 :: 		RXNEIE_USART1_CR1_bit = 1;      // rx interrupts on
	R0 <4> <- addr(RXNEIE_USART1_CR1_bit)   (midx: 0)
	[R0] <0> <- R1   (midx: 0)
//HW_V1_Config.c,119 :: 		TXEIE_USART1_CR1_bit = 0;
	R0 <4> <- addr(TXEIE_USART1_CR1_bit)   (midx: 0)
	[R0] <0> <- R2   (midx: 0)
//HW_V1_Config.c,120 :: 		TE_bit = 1;                     // tx 1 always enabled
	R0 <4> <- addr(TE_bit)   (midx: 0)
	[R0] <0> <- R1   (midx: 0)
  end
   (midx: 0)
_InitTimers:
  begin   (midx: 0)
//HW_V1_Config.c,126 :: 		void InitTimers(void)
_InitTimers:
  begin   (midx: 0)
//HW_V1_Config.c,129 :: 		RCC_APB1ENR.TIM2EN = 1;         // Enable clock gating for timer module 2
	R1 <1> <- 1   (midx: 0)
	R0 <4> <- addr(RCC_APB1ENR)   (midx: 0)
	[R0] <0> <- R1   (midx: 20)
//HW_V1_Config.c,130 :: 		TIM2_CR1.CEN = 0;               // Disable timer
	R1 <1> <- 0   (midx: 0)
	R0 <4> <- addr(TIM2_CR1)   (midx: 0)
	[R0] <0> <- R1   (midx: 20)
//HW_V1_Config.c,131 :: 		TIM2_PSC = 0;                   // Set timer prescaler to 0
	R1 <4> <- 0   (midx: 0)
	R0 <4> <- addr(TIM2_PSC)   (midx: 0)
	[R0] <4> <- R1   (midx: 0)
//HW_V1_Config.c,132 :: 		TIM2_ARR = 36000;               // 36Mhz clock counts 36000 times for 1ms interval
	R1 <4> <- 36000   (midx: 0)
	R0 <4> <- addr(TIM2_ARR)   (midx: 0)
	[R0] <4> <- R1   (midx: 0)
//HW_V1_Config.c,133 :: 		NVIC_IntEnable(IVT_INT_TIM2);   // Enable timer interrupt
	R0 <4> <- 44   (midx: 0)
	CALL _NVIC_IntEnable   (midx: 0)
//HW_V1_Config.c,134 :: 		TIM2_DIER.UIE = 1;              // Update interrupt enable
	R1 <1> <- 1   (midx: 0)
	R0 <4> <- addr(TIM2_DIER)   (midx: 0)
	[R0] <0> <- R1   (midx: 20)
//HW_V1_Config.c,135 :: 		TIM2_CR1.CEN = 1;               // Enable timer
	R0 <4> <- addr(TIM2_CR1)   (midx: 0)
	[R0] <0> <- R1   (midx: 20)
  end
   (midx: 0)
_KeyScan:
  begin   (midx: 0)
//HW_V1_Config.c,145 :: 		char KeyScan(void)
_KeyScan:
  begin   (midx: 0)
//HW_V1_Config.c,147 :: 		char Key_Status_Now=0, KeyCode=0;
   (midx: 0)
   (midx: 0)
	R1 <-initialize(0)   (midx: 0)
   (midx: 0)
	R0 <4> <- 0   (midx: 0)
	KeyScan_KeyCode_L0 <-initialize(0)   (midx: 0)
//HW_V1_Config.c,149 :: 		if((~GPIOA_IDR) & 0x0010) Key_Status_Now |= 0x01; //KEY_PLAY_ON
	R0 <4> <- addr(GPIOA_IDR)   (midx: 0)
	R0 <4> <- [R0]   (midx: 0)
	R0 <4> <- ~R0   (midx: 2)
	R0 <4> <-  R0 & 16   (midx: 2)
	if (!R0) then goto 27   (midx: 0)
   (midx: 0)
	R2 <1> <-  R1 | 1   (midx: 0)
   (midx: 0)
   (midx: 0)
	R2 <1> <- R2   (midx: 0)
	R1 <1> <- R2   (midx: 0)
	goto	0   (midx: 0)
27:   (midx: 0)
	R1 <1> <- R1   (midx: 0)
0:   (midx: 0)
//HW_V1_Config.c,150 :: 		if((~GPIOD_IDR) & 0x0800) Key_Status_Now |= 0x02; //KEY_MENU_ON
   (midx: 0)
	R0 <4> <- addr(GPIOD_IDR)   (midx: 0)
	R0 <4> <- [R0]   (midx: 0)
	R0 <4> <- ~R0   (midx: 2)
	R0 <4> <-  R0 & 2048   (midx: 2)
	if (!R0) then goto 28   (midx: 0)
   (midx: 0)
	R2 <1> <-  R1 | 2   (midx: 0)
   (midx: 0)
   (midx: 0)
	R2 <1> <- R2   (midx: 0)
	R1 <1> <- R2   (midx: 0)
	goto	1   (midx: 0)
28:   (midx: 0)
	R1 <1> <- R1   (midx: 0)
1:   (midx: 0)
//HW_V1_Config.c,151 :: 		if((~GPIOA_IDR) & 0x0040) Key_Status_Now |= 0x04; //KEY_UP_ON
   (midx: 0)
	R0 <4> <- addr(GPIOA_IDR)   (midx: 0)
	R0 <4> <- [R0]   (midx: 0)
	R0 <4> <- ~R0   (midx: 2)
	R0 <4> <-  R0 & 64   (midx: 2)
	if (!R0) then goto 29   (midx: 0)
   (midx: 0)
	R2 <1> <-  R1 | 4   (midx: 0)
   (midx: 0)
   (midx: 0)
	R2 <1> <- R2   (midx: 0)
	R1 <1> <- R2   (midx: 0)
	goto	2   (midx: 0)
29:   (midx: 0)
	R1 <1> <- R1   (midx: 0)
2:   (midx: 0)
//HW_V1_Config.c,152 :: 		if((~GPIOD_IDR) & 0x0200) Key_Status_Now |= 0x08; //KEY_DOWN_ON
   (midx: 0)
	R0 <4> <- addr(GPIOD_IDR)   (midx: 0)
	R0 <4> <- [R0]   (midx: 0)
	R0 <4> <- ~R0   (midx: 2)
	R0 <4> <-  R0 & 512   (midx: 2)
	if (!R0) then goto 30   (midx: 0)
   (midx: 0)
	R2 <1> <-  R1 | 8   (midx: 0)
   (midx: 0)
   (midx: 0)
	R2 <1> <- R2   (midx: 0)
	R2 <1> <- R2   (midx: 0)
	goto	3   (midx: 0)
30:   (midx: 0)
	R2 <1> <- R1   (midx: 0)
3:   (midx: 0)
//HW_V1_Config.c,153 :: 		if((~GPIOA_IDR) & 0x0020) Key_Status_Now |= 0x10; //KEY_LEFT_ON
   (midx: 0)
	R0 <4> <- addr(GPIOA_IDR)   (midx: 0)
	R0 <4> <- [R0]   (midx: 0)
	R0 <4> <- ~R0   (midx: 2)
	R0 <4> <-  R0 & 32   (midx: 2)
	if (!R0) then goto 31   (midx: 0)
   (midx: 0)
	R1 <1> <-  R2 | 16   (midx: 0)
   (midx: 0)
   (midx: 0)
	R1 <1> <- R1   (midx: 0)
	R2 <1> <- R1   (midx: 0)
	goto	4   (midx: 0)
31:   (midx: 0)
	R2 <1> <- R2   (midx: 0)
4:   (midx: 0)
//HW_V1_Config.c,154 :: 		if((~GPIOA_IDR) & 0x0080) Key_Status_Now |= 0x20; //KEY_RIGHT_ON
   (midx: 0)
	R0 <4> <- addr(GPIOA_IDR)   (midx: 0)
	R0 <4> <- [R0]   (midx: 0)
	R0 <4> <- ~R0   (midx: 2)
	R0 <4> <-  R0 & 128   (midx: 2)
	if (!R0) then goto 32   (midx: 0)
   (midx: 0)
	R0 <1> <-  R2 | 32   (midx: 0)
   (midx: 0)
   (midx: 0)
	R1 <1> <- R0   (midx: 0)
	R2 <1> <- R1   (midx: 0)
	goto	5   (midx: 0)
32:   (midx: 0)
	R2 <1> <- R2   (midx: 0)
5:   (midx: 0)
//HW_V1_Config.c,156 :: 		if(Key_Status_Now &(~Key_Status_Last)){
   (midx: 0)
	R0 <4> <- addr(_Key_Status_Last)   (midx: 0)
	R0 <1> <- [R0]   (midx: 0)
	R0 <1> <- ~R0   (midx: 0)
	R0 <1> <-  R2 & R0   (midx: 0)
	if (!R0) then goto 6   (midx: 0)
//HW_V1_Config.c,158 :: 		Key_Wait_Counter=25;        //Push on <500mS, No auto repeat
	R1 <1> <- 25   (midx: 0)
	R0 <4> <- addr(_Key_Wait_Counter)   (midx: 0)
	[R0] <1> <- R1   (midx: 0)
//HW_V1_Config.c,160 :: 		if(Key_Status_Now & 0x01)  KeyCode=KEYCODE_PLAY; // KeyCode(Play)
	R0 <1> <-  R2 & 1   (midx: 0)
	if (!R0) then goto 7   (midx: 0)
	R0 <1> <- 1   (midx: 0)
	KeyScan_KeyCode_L0 <1> <- R0   (midx: 0)
7:   (midx: 0)
//HW_V1_Config.c,161 :: 		if(Key_Status_Now & 0x02)  KeyCode=KEYCODE_MANU; // KeyCode(Manu)
	R0 <1> <-  R2 & 2   (midx: 0)
	if (!R0) then goto 8   (midx: 0)
	R0 <1> <- 2   (midx: 0)
	KeyScan_KeyCode_L0 <1> <- R0   (midx: 0)
8:   (midx: 0)
//HW_V1_Config.c,162 :: 		if(Key_Status_Now & 0x04)  KeyCode=KEYCODE_UP;   // KeyCode(Up)
	R0 <1> <-  R2 & 4   (midx: 0)
	if (!R0) then goto 9   (midx: 0)
	R0 <1> <- 3   (midx: 0)
	KeyScan_KeyCode_L0 <1> <- R0   (midx: 0)
9:   (midx: 0)
//HW_V1_Config.c,163 :: 		if(Key_Status_Now & 0x08)  KeyCode=KEYCODE_DOWN; // KeyCode(Down)
	R0 <1> <-  R2 & 8   (midx: 0)
	if (!R0) then goto 10   (midx: 0)
	R0 <1> <- 4   (midx: 0)
	KeyScan_KeyCode_L0 <1> <- R0   (midx: 0)
10:   (midx: 0)
//HW_V1_Config.c,164 :: 		if(Key_Status_Now & 0x10)  KeyCode=KEYCODE_LEFT; // KeyCode(Left)
	R0 <1> <-  R2 & 16   (midx: 0)
	if (!R0) then goto 11   (midx: 0)
	R0 <1> <- 5   (midx: 0)
	KeyScan_KeyCode_L0 <1> <- R0   (midx: 0)
11:   (midx: 0)
//HW_V1_Config.c,165 :: 		if(Key_Status_Now & 0x20)  KeyCode=KEYCODE_RIGHT;// KeyCode(Right)
	R0 <1> <-  R2 & 32   (midx: 0)
	if (!R0) then goto 12   (midx: 0)
	R0 <1> <- 6   (midx: 0)
	KeyScan_KeyCode_L0 <1> <- R0   (midx: 0)
12:   (midx: 0)
//HW_V1_Config.c,167 :: 		} else {
	goto	13   (midx: 0)
6:   (midx: 0)
//HW_V1_Config.c,169 :: 		if(Key_Status_Now & Key_Status_Last){
	R0 <4> <- addr(_Key_Status_Last)   (midx: 0)
	R0 <1> <- [R0]   (midx: 0)
	R0 <1> <-  R2 & R0   (midx: 0)
	if (!R0) then goto 14   (midx: 0)
//HW_V1_Config.c,170 :: 		if((Key_Wait_Counter | Key_Repeat_Counter)==0){
	R0 <4> <- addr(_Key_Repeat_Counter)   (midx: 0)
	R1 <1> <- [R0]   (midx: 0)
	R0 <4> <- addr(_Key_Wait_Counter)   (midx: 0)
	R0 <1> <- [R0]   (midx: 0)
	R0 <1> <-  R0 | R1   (midx: 0)
	if ( R0 != 0) then goto 15   (midx: 0)
//HW_V1_Config.c,172 :: 		if(Key_Status_Now & 0x01)  KeyCode=KEYCODE_PLAY; // KeyCode(Play)
	R0 <1> <-  R2 & 1   (midx: 0)
	if (!R0) then goto 16   (midx: 0)
	R0 <1> <- 1   (midx: 0)
	KeyScan_KeyCode_L0 <1> <- R0   (midx: 0)
16:   (midx: 0)
//HW_V1_Config.c,173 :: 		if(Key_Status_Now & 0x02)  KeyCode=KEYCODE_MANU; // KeyCode(Manu)
	R0 <1> <-  R2 & 2   (midx: 0)
	if (!R0) then goto 17   (midx: 0)
	R0 <1> <- 2   (midx: 0)
	KeyScan_KeyCode_L0 <1> <- R0   (midx: 0)
17:   (midx: 0)
//HW_V1_Config.c,174 :: 		if(Key_Status_Now & 0x04)  KeyCode=KEYCODE_UP;   // KeyCode(Up)
	R0 <1> <-  R2 & 4   (midx: 0)
	if (!R0) then goto 18   (midx: 0)
	R0 <1> <- 3   (midx: 0)
	KeyScan_KeyCode_L0 <1> <- R0   (midx: 0)
18:   (midx: 0)
//HW_V1_Config.c,175 :: 		if(Key_Status_Now & 0x08)  KeyCode=KEYCODE_DOWN; // KeyCode(Down)
	R0 <1> <-  R2 & 8   (midx: 0)
	if (!R0) then goto 19   (midx: 0)
	R0 <1> <- 4   (midx: 0)
	KeyScan_KeyCode_L0 <1> <- R0   (midx: 0)
19:   (midx: 0)
//HW_V1_Config.c,176 :: 		if(Key_Status_Now & 0x10)  KeyCode=KEYCODE_LEFT; // KeyCode(Left)
	R0 <1> <-  R2 & 16   (midx: 0)
	if (!R0) then goto 20   (midx: 0)
	R0 <1> <- 5   (midx: 0)
	KeyScan_KeyCode_L0 <1> <- R0   (midx: 0)
20:   (midx: 0)
//HW_V1_Config.c,177 :: 		if(Key_Status_Now & 0x20)  KeyCode=KEYCODE_RIGHT;// KeyCode(Right)
	R0 <1> <-  R2 & 32   (midx: 0)
	if (!R0) then goto 21   (midx: 0)
	R0 <1> <- 6   (midx: 0)
	KeyScan_KeyCode_L0 <1> <- R0   (midx: 0)
21:   (midx: 0)
//HW_V1_Config.c,179 :: 		Key_Repeat_Counter = 3; //Auto repeat each 60mS
	R1 <1> <- 3   (midx: 0)
	R0 <4> <- addr(_Key_Repeat_Counter)   (midx: 0)
	[R0] <1> <- R1   (midx: 0)
//HW_V1_Config.c,180 :: 		}
15:   (midx: 0)
//HW_V1_Config.c,181 :: 		}else Key_Wait_Counter=25;
	goto	22   (midx: 0)
14:   (midx: 0)
	R1 <1> <- 25   (midx: 0)
	R0 <4> <- addr(_Key_Wait_Counter)   (midx: 0)
	[R0] <1> <- R1   (midx: 0)
22:   (midx: 0)
//HW_V1_Config.c,182 :: 		}
13:   (midx: 0)
//HW_V1_Config.c,183 :: 		Key_Status_Last = Key_Status_Now;
	R0 <4> <- addr(_Key_Status_Last)   (midx: 0)
   (midx: 0)
	[R0] <1> <- R2   (midx: 0)
//HW_V1_Config.c,184 :: 		return KeyCode;
	R0 <1> <- KeyScan_KeyCode_L0   (midx: 0)
	return   (midx: 0)
  end
   (midx: 0)
_Test_USB_ON:
  begin   (midx: 0)
//HW_V1_Config.c,190 :: 		char Test_USB_ON(void)
_Test_USB_ON:
  begin   (midx: 0)
//HW_V1_Config.c,192 :: 		if(GPIOB_IDR &0x0400) return 1;
	R0 <4> <- addr(GPIOB_IDR)   (midx: 0)
	R0 <4> <- [R0]   (midx: 0)
	R0 <4> <-  R0 & 1024   (midx: 2)
	if (!R0) then goto 23   (midx: 0)
	R0 <1> <- 1   (midx: 0)
	return   (midx: 0)
23:   (midx: 0)
//HW_V1_Config.c,193 :: 		else  return 0;
	R0 <1> <- 0   (midx: 0)
	return   (midx: 0)
  end
   (midx: 0)
_SD_Card_ON:
  begin   (midx: 0)
//HW_V1_Config.c,199 :: 		char SD_Card_ON(void)
_SD_Card_ON:
  begin   (midx: 0)
//HW_V1_Config.c,201 :: 		if(GPIOD_IDR &0x0400) return 1;
	R0 <4> <- addr(GPIOD_IDR)   (midx: 0)
	R0 <4> <- [R0]   (midx: 0)
	R0 <4> <-  R0 & 1024   (midx: 2)
	if (!R0) then goto 25   (midx: 0)
	R0 <1> <- 1   (midx: 0)
	return   (midx: 0)
25:   (midx: 0)
//HW_V1_Config.c,202 :: 		else  return 0;
	R0 <1> <- 0   (midx: 0)
	return   (midx: 0)
  end
   (midx: 0)
