_String2Send:
  begin   (midx: 0)
//main.c,43 :: 		void String2Send(void)
_String2Send:
  begin   (midx: 0)
//main.c,48 :: 		for (x=0; x<MAX_KEY_IN_CHARS; x++){
   (midx: 0)
   (midx: 0)
	R3 <1> <- 0   (midx: 0)
	R3 <1> <- R3   (midx: 0)
0:   (midx: 0)
   (midx: 0)
	if ( R3 >= 8) then goto 1   (midx: 4)
//main.c,49 :: 		cByte = val_tab[in_value[x]];
	R0 <4> <- #_in_value   (midx: 0)
	R0 <4> <-  R0 + R3   (midx: 2)
	R1 <1> <- *R0   (midx: 0)
	R0 <4> <- #_val_tab   (midx: 0)
	R0 <4> <-  R0 + R1   (midx: 2)
	R0 <1> <- *R0   (midx: 0)
   (midx: 0)
	R2 <1> <- R0   (midx: 0)
//main.c,50 :: 		if (cByte != ' '){
   (midx: 0)
   (midx: 0)
	if ( R0 = 32) then goto 65   (midx: 0)
	R3 <1> <- R3   (midx: 0)
	R2 <1> <- R2   (midx: 0)
//main.c,51 :: 		while (!TXE_USART1_SR_bit);                 // sit here and wait until tx is ready
4:   (midx: 0)
   (midx: 0)
   (midx: 0)
	R1 <4> <- addr(TXE_USART1_SR_bit)   (midx: 0)
	R0 <4> <- [R1]   (midx: 0)
	if (R0) then goto 5   (midx: 0)
	R3 <1> <- R3   (midx: 0)
	R2 <1> <- R2   (midx: 0)
	goto	4   (midx: 0)
5:   (midx: 0)
//main.c,52 :: 		USART1_DR = (unsigned int) cByte & 0x00ff;
   (midx: 0)
	R0 <2> <- R2   (midx: 0)
	R1 <2> <-  R0 & 255   (midx: 1)
	R0 <4> <- addr(USART1_DR)   (midx: 0)
	[R0] <4> <- R1   (midx: 0)
//main.c,53 :: 		Delay_ms(1);
	asm: -1   (midx: 1)
	asm: -1   (midx: 1)
	asm: -1   (midx: 1)
	asm: -1   (midx: 1)
	asm: -1   (midx: 2)
	asm: -1   (midx: 1)
	asm: -1   (midx: 5)
	asm: -1   (midx: 1)
	asm: -1   (midx: 1)
	asm: -1   (midx: 1)
   (midx: 0)
	asm: -1   (midx: 1)
	R1 <1> <- R3   (midx: 0)
//main.c,54 :: 		}
	goto	3   (midx: 0)
65:   (midx: 0)
//main.c,50 :: 		if (cByte != ' '){
	R1 <1> <- R3   (midx: 0)
//main.c,54 :: 		}
3:   (midx: 0)
//main.c,48 :: 		for (x=0; x<MAX_KEY_IN_CHARS; x++){
   (midx: 0)
   (midx: 0)
	R0 <1> <-  R1 + 1   (midx: 0)
   (midx: 0)
	R3 <1> <- R0   (midx: 0)
//main.c,55 :: 		}
   (midx: 0)
	R3 <1> <- R3   (midx: 0)
	goto	0   (midx: 0)
1:   (midx: 0)
//main.c,57 :: 		USART1_DR = (unsigned int) cByte & 0x00ff;
	R1 <4> <- 13   (midx: 0)
	R0 <4> <- addr(USART1_DR)   (midx: 0)
	[R0] <4> <- R1   (midx: 0)
  end
   (midx: 0)
_isAvailable:
  begin   (midx: 0)
//main.c,60 :: 		char isAvailable()
_isAvailable:
  begin   (midx: 0)
//main.c,62 :: 		return (in_ptr != out_ptr);
	R0 <4> <- addr(main_out_ptr)   (midx: 0)
	R1 <2> <- [R0]   (midx: 0)
	R0 <4> <- addr(main_in_ptr)   (midx: 0)
	R0 <2> <- [R0]   (midx: 0)
	R0 <1> <-  R0 != R1   (midx: 1)
	R0 <1> <- R0   (midx: 0)
	return   (midx: 0)
  end
   (midx: 0)
_getChar:
  begin   (midx: 0)
//main.c,65 :: 		char getChar()
_getChar:
  begin   (midx: 0)
//main.c,68 :: 		ch = in_buffer[out_ptr++];
	R2 <4> <- addr(main_out_ptr)   (midx: 0)
	R1 <4> <- [R2]   (midx: 0)
	R0 <4> <- #main_in_buffer   (midx: 0)
	R0 <4> <-  R0 + R1   (midx: 2)
	R0 <1> <- *R0   (midx: 0)
   (midx: 0)
	R3 <1> <- R0   (midx: 0)
	R0 <4> <- R2   (midx: 0)
	R0 <2> <- [R0]   (midx: 0)
	R0 <2> <-  R0 + 1   (midx: 1)
	[R2] <2> <- R0   (midx: 0)
//main.c,69 :: 		if (out_ptr >= MAX_IN_BUFFER) out_ptr = 0;
	if ( R0 < 128) then goto 7   (midx: 1)
	R1 <2> <- 0   (midx: 0)
	R0 <4> <- addr(main_out_ptr)   (midx: 0)
	[R0] <2> <- R1   (midx: 0)
7:   (midx: 0)
//main.c,70 :: 		return ch;
   (midx: 0)
	R0 <1> <- R3   (midx: 0)
	return   (midx: 0)
  end
   (midx: 0)
_ClearNextTextLine:
  begin   (midx: 0)
//main.c,73 :: 		void ClearNextTextLine(int y_cur_pos, unsigned int Color)
_ClearNextTextLine:
  begin   (midx: 0)
	FARG_ClearNextTextLine_y_cur_pos <2> <- R0   (midx: 0)
   (midx: 0)
	FARG_ClearNextTextLine_Color <2> <- R1   (midx: 0)
//main.c,77 :: 		if (y_cur_pos-STEP_Y_POS >= 0){                                         // make sure we only use positive values
	R2 <2> <- FARG_ClearNextTextLine_y_cur_pos   (midx: 0)
	R2 <2> <-  R2 - 14   (midx: 5)
	if ( R2 < 0) then goto 8   (midx: 5)
//main.c,78 :: 		for(i=0; i<320; ++i) {                                              // 320 pixels = full horizontal scan line
	R2 <2> <- 0   (midx: 0)
	ClearNextTextLine_i_L0 <2> <- R2   (midx: 0)
9:   (midx: 0)
	R2 <2> <- ClearNextTextLine_i_L0   (midx: 0)
	if ( R2 >= 320) then goto 10   (midx: 1)
//main.c,79 :: 		Point_SCR(i,y_cur_pos-STEP_Y_POS);                              // set screen addresses
	R2 <2> <- FARG_ClearNextTextLine_y_cur_pos   (midx: 0)
	R2 <2> <-  R2 - 14   (midx: 5)
	R1 <2> <- R2   (midx: 0)
	R0 <2> <- ClearNextTextLine_i_L0   (midx: 0)
	CALL _Point_SCR   (midx: 0)
//main.c,80 :: 		for(j=y_cur_pos-STEP_Y_POS; j<y_cur_pos; ++j)                   // rows are 1 character tall = 14
	R2 <2> <- FARG_ClearNextTextLine_y_cur_pos   (midx: 0)
	R2 <2> <-  R2 - 14   (midx: 5)
	ClearNextTextLine_j_L0 <2> <- R2   (midx: 0)
12:   (midx: 0)
	R3 <2> <- FARG_ClearNextTextLine_y_cur_pos   (midx: 0)
	R2 <2> <- ClearNextTextLine_j_L0   (midx: 0)
	if ( R2 >= R3) then goto 13   (midx: 1)
//main.c,81 :: 		Set_Pixel(Color);                                           // make the pixels black
	R0 <2> <- FARG_ClearNextTextLine_Color   (midx: 0)
	CALL _Set_Pixel   (midx: 0)
//main.c,80 :: 		for(j=y_cur_pos-STEP_Y_POS; j<y_cur_pos; ++j)                   // rows are 1 character tall = 14
	R2 <2> <- ClearNextTextLine_j_L0   (midx: 0)
	R2 <2> <-  R2 + 1   (midx: 1)
	ClearNextTextLine_j_L0 <2> <- R2   (midx: 0)
//main.c,81 :: 		Set_Pixel(Color);                                           // make the pixels black
	goto	12   (midx: 0)
13:   (midx: 0)
//main.c,78 :: 		for(i=0; i<320; ++i) {                                              // 320 pixels = full horizontal scan line
	R2 <2> <- ClearNextTextLine_i_L0   (midx: 0)
	R2 <2> <-  R2 + 1   (midx: 1)
	ClearNextTextLine_i_L0 <2> <- R2   (midx: 0)
//main.c,82 :: 		}
	goto	9   (midx: 0)
10:   (midx: 0)
//main.c,83 :: 		}
8:   (midx: 0)
  end
   (midx: 0)
_Handle_UART_Input:
  begin   (midx: 0)
//main.c,86 :: 		void Handle_UART_Input()
_Handle_UART_Input:
  begin   (midx: 0)
//main.c,90 :: 		if (isAvailable()){
	CALL _isAvailable   (midx: 0)
	if (!R0) then goto 15   (midx: 0)
//main.c,91 :: 		bPrompt = 0;                                            // cancel prompt signal
	R1 <1> <- 0   (midx: 0)
	R0 <4> <- addr(_bPrompt)   (midx: 0)
	[R0] <0> <- R1   (midx: 0)
//main.c,92 :: 		ch = getChar();
	CALL _getChar   (midx: 0)
   (midx: 0)
	R0 <1> <- R0   (midx: 0)
//main.c,93 :: 		switch (ch){
   (midx: 0)
	goto	16   (midx: 0)
//main.c,94 :: 		case 0x1B:                                          // ESC signals screen clear
18:   (midx: 0)
//main.c,95 :: 		x_pos = 1;
	R1 <2> <- 1   (midx: 0)
	R0 <4> <- addr(main_x_pos)   (midx: 0)
	[R0] <2> <- R1   (midx: 0)
//main.c,96 :: 		y_pos =  MAX_Y_POS-STEP_Y_POS;                  // go back to top
	R1 <2> <- 224   (midx: 0)
	R0 <4> <- addr(main_y_pos)   (midx: 0)
	[R0] <2> <- R1   (midx: 0)
//main.c,97 :: 		Clear_Screen(BLACK);
	R0 <2> <- 0   (midx: 0)
	CALL _Clear_Screen   (midx: 0)
//main.c,98 :: 		break;
	goto	17   (midx: 0)
//main.c,99 :: 		case '\r': x_pos = 1; break;                        // <CR> just go back to line start
19:   (midx: 0)
	R1 <2> <- 1   (midx: 0)
	R0 <4> <- addr(main_x_pos)   (midx: 0)
	[R0] <2> <- R1   (midx: 0)
	goto	17   (midx: 0)
//main.c,100 :: 		case '\n':                                          // <LF> line feed
20:   (midx: 0)
//main.c,101 :: 		ClearNextTextLine(y_pos, BLACK);                // make sure the next line is empty
	R0 <4> <- addr(main_y_pos)   (midx: 0)
	R0 <2> <- [R0]   (midx: 0)
	R1 <2> <- 0   (midx: 0)
	R0 <2> <- R0   (midx: 0)
	CALL _ClearNextTextLine   (midx: 0)
//main.c,102 :: 		y_pos-=STEP_Y_POS;                              // move to next text row (y is reversed!)
	R1 <4> <- addr(main_y_pos)   (midx: 0)
	R0 <2> <- [R1]   (midx: 0)
	R0 <2> <-  R0 - 14   (midx: 5)
	[R1] <2> <- R0   (midx: 0)
//main.c,103 :: 		if (y_pos < 0){                                 // if we are at the Y bottom
	if ( R0 >= 0) then goto 21   (midx: 5)
//main.c,104 :: 		y_pos =  MAX_Y_POS-STEP_Y_POS;              // go back to top
	R1 <2> <- 224   (midx: 0)
	R0 <4> <- addr(main_y_pos)   (midx: 0)
	[R0] <2> <- R1   (midx: 0)
//main.c,105 :: 		}
21:   (midx: 0)
//main.c,106 :: 		break;
	goto	17   (midx: 0)
//main.c,107 :: 		default:
22:   (midx: 0)
//main.c,108 :: 		Display_Char(x_pos, y_pos, WHITE,PRN, ch);      // show the current displayable character
   (midx: 0)
   (midx: 0)
	R2 <1> <- R0   (midx: 0)
	R0 <4> <- addr(main_y_pos)   (midx: 0)
	R1 <2> <- [R0]   (midx: 0)
	R0 <4> <- addr(main_x_pos)   (midx: 0)
	R0 <2> <- [R0]   (midx: 0)
	FARG_Display_Char_s <1> <- PUSH(R2)   (midx: 0)
	R3 <1> <- 0   (midx: 0)
	R2 <2> <- 65535   (midx: 0)
	R1 <2> <- R1   (midx: 0)
	R0 <2> <- R0   (midx: 0)
	CALL _Display_Char   (midx: 0)
//main.c,109 :: 		x_pos+=STEP_X_POS;                              // move to next character position
	R2 <4> <- addr(main_x_pos)   (midx: 0)
	R0 <2> <- [R2]   (midx: 0)
	R1 <2> <-  R0 + 9   (midx: 5)
	[R2] <2> <- R1   (midx: 0)
//main.c,110 :: 		if (x_pos >= MAX_X_POS){                        // if we hit last column then wrap
	R0 <4> <- 315   (midx: 0)
	if ( R1 < R0) then goto 23   (midx: 5)
//main.c,111 :: 		x_pos = 1;                                  // move x to starting column
	R1 <2> <- 1   (midx: 0)
	R0 <4> <- addr(main_x_pos)   (midx: 0)
	[R0] <2> <- R1   (midx: 0)
//main.c,112 :: 		ClearNextTextLine(y_pos, BLACK);            // make sure the next line is empty
	R0 <4> <- addr(main_y_pos)   (midx: 0)
	R0 <2> <- [R0]   (midx: 0)
	R1 <2> <- 0   (midx: 0)
	R0 <2> <- R0   (midx: 0)
	CALL _ClearNextTextLine   (midx: 0)
//main.c,113 :: 		y_pos-=STEP_Y_POS;                          // move to next text row (y is reversed!)
	R1 <4> <- addr(main_y_pos)   (midx: 0)
	R0 <2> <- [R1]   (midx: 0)
	R0 <2> <-  R0 - 14   (midx: 5)
	[R1] <2> <- R0   (midx: 0)
//main.c,114 :: 		if (y_pos < 0){                             // if we are at the Y bottom
	if ( R0 >= 0) then goto 24   (midx: 5)
//main.c,115 :: 		y_pos =  MAX_Y_POS-STEP_Y_POS;          // go back to top
	R1 <2> <- 224   (midx: 0)
	R0 <4> <- addr(main_y_pos)   (midx: 0)
	[R0] <2> <- R1   (midx: 0)
//main.c,116 :: 		}
24:   (midx: 0)
//main.c,117 :: 		}
23:   (midx: 0)
//main.c,118 :: 		break;
	goto	17   (midx: 0)
//main.c,119 :: 		}
16:   (midx: 0)
   (midx: 0)
	if ( R0 = 27) then goto 18   (midx: 0)
	if ( R0 = 13) then goto 19   (midx: 0)
	if ( R0 = 10) then goto 20   (midx: 0)
   (midx: 0)
	goto	22   (midx: 0)
17:   (midx: 0)
//main.c,120 :: 		}
15:   (midx: 0)
  end
   (midx: 0)
_HandleKeyPress:
  begin   (midx: 0)
//main.c,123 :: 		void HandleKeyPress(void)
_HandleKeyPress:
  begin   (midx: 0)
//main.c,127 :: 		cur_key_press = KeyScan();
	CALL _KeyScan   (midx: 0)
	R1 <4> <- addr(main_cur_key_press)   (midx: 0)
	[R1] <1> <- R0   (midx: 0)
//main.c,128 :: 		switch (cur_key_press){
	goto	25   (midx: 0)
//main.c,129 :: 		case KEYCODE_VOID:                              // no keys are pressed
27:   (midx: 0)
//main.c,130 :: 		if (bPrompt){                               // but a good place to handle prompt feature
	R1 <4> <- addr(_bPrompt)   (midx: 0)
	R0 <4> <- [R1]   (midx: 0)
	if (!R0) then goto 28   (midx: 0)
//main.c,131 :: 		if (++prompt_count==10){
	R1 <4> <- addr(HandleKeyPress_prompt_count_L0)   (midx: 0)
	R0 <2> <- [R1]   (midx: 0)
	R0 <2> <-  R0 + 1   (midx: 1)
	[R1] <2> <- R0   (midx: 0)
	if ( R0 != 10) then goto 29   (midx: 5)
//main.c,132 :: 		Display_Char(x_pos, y_pos, WHITE,PRN, '_');     // show '_'
	R2 <1> <- 95   (midx: 0)
	R0 <4> <- addr(main_y_pos)   (midx: 0)
	R1 <2> <- [R0]   (midx: 0)
	R0 <4> <- addr(main_x_pos)   (midx: 0)
	R0 <2> <- [R0]   (midx: 0)
	FARG_Display_Char_s <1> <- PUSH(R2)   (midx: 0)
	R3 <1> <- 0   (midx: 0)
	R2 <2> <- 65535   (midx: 0)
	R1 <2> <- R1   (midx: 0)
	R0 <2> <- R0   (midx: 0)
	CALL _Display_Char   (midx: 0)
//main.c,133 :: 		} else if (prompt_count==20){
	goto	30   (midx: 0)
29:   (midx: 0)
	R0 <4> <- addr(HandleKeyPress_prompt_count_L0)   (midx: 0)
	R0 <2> <- [R0]   (midx: 0)
	if ( R0 != 20) then goto 31   (midx: 5)
//main.c,134 :: 		prompt_count = 0;
	R1 <2> <- 0   (midx: 0)
	R0 <4> <- addr(HandleKeyPress_prompt_count_L0)   (midx: 0)
	[R0] <2> <- R1   (midx: 0)
//main.c,135 :: 		Display_Char(x_pos, y_pos, WHITE,PRN, val_tab[in_value[in_value_index]]);   // now show char
	R0 <4> <- addr(_in_value_index)   (midx: 0)
	R1 <4> <- [R0]   (midx: 0)
	R0 <4> <- #_in_value   (midx: 0)
	R0 <4> <-  R0 + R1   (midx: 2)
	R1 <1> <- *R0   (midx: 0)
	R0 <4> <- #_val_tab   (midx: 0)
	R0 <4> <-  R0 + R1   (midx: 2)
	R0 <1> <- *R0   (midx: 0)
	R2 <1> <- R0   (midx: 0)
	R0 <4> <- addr(main_y_pos)   (midx: 0)
	R1 <2> <- [R0]   (midx: 0)
	R0 <4> <- addr(main_x_pos)   (midx: 0)
	R0 <2> <- [R0]   (midx: 0)
	FARG_Display_Char_s <1> <- PUSH(R2)   (midx: 0)
	R3 <1> <- 0   (midx: 0)
	R2 <2> <- 65535   (midx: 0)
	R1 <2> <- R1   (midx: 0)
	R0 <2> <- R0   (midx: 0)
	CALL _Display_Char   (midx: 0)
//main.c,136 :: 		}
31:   (midx: 0)
30:   (midx: 0)
//main.c,137 :: 		}
28:   (midx: 0)
//main.c,138 :: 		break;
	goto	26   (midx: 0)
//main.c,140 :: 		case KEYCODE_PLAY:                              // this is the A button
32:   (midx: 0)
//main.c,141 :: 		x_pos = 1;
	R1 <2> <- 1   (midx: 0)
	R0 <4> <- addr(main_x_pos)   (midx: 0)
	[R0] <2> <- R1   (midx: 0)
//main.c,142 :: 		y_pos =  MAX_Y_POS-STEP_Y_POS;              // go back to top
	R1 <2> <- 224   (midx: 0)
	R0 <4> <- addr(main_y_pos)   (midx: 0)
	[R0] <2> <- R1   (midx: 0)
//main.c,143 :: 		Clear_Screen(BLACK);
	R0 <2> <- 0   (midx: 0)
	CALL _Clear_Screen   (midx: 0)
//main.c,144 :: 		break;
	goto	26   (midx: 0)
//main.c,146 :: 		case KEYCODE_MANU:
33:   (midx: 0)
//main.c,147 :: 		String2Send();
	CALL _String2Send   (midx: 0)
//main.c,148 :: 		ClearNextTextLine(y_pos+STEP_Y_POS, BLACK);            // make sure the next line is empty
	R0 <4> <- addr(main_y_pos)   (midx: 0)
	R0 <2> <- [R0]   (midx: 0)
	R0 <2> <-  R0 + 14   (midx: 5)
	R1 <2> <- 0   (midx: 0)
	R0 <2> <- R0   (midx: 0)
	CALL _ClearNextTextLine   (midx: 0)
//main.c,149 :: 		bPrompt = 0;
	R1 <1> <- 0   (midx: 0)
	R0 <4> <- addr(_bPrompt)   (midx: 0)
	[R0] <0> <- R1   (midx: 0)
//main.c,150 :: 		for (in_value_index=0; in_value_index<MAX_KEY_IN_CHARS; in_value_index++)
	R1 <1> <- 0   (midx: 0)
	R0 <4> <- addr(_in_value_index)   (midx: 0)
	[R0] <1> <- R1   (midx: 0)
34:   (midx: 0)
	R0 <4> <- addr(_in_value_index)   (midx: 0)
	R0 <1> <- [R0]   (midx: 0)
	if ( R0 >= 8) then goto 35   (midx: 0)
//main.c,151 :: 		in_value[in_value_index] = 0;
	R2 <4> <- addr(_in_value_index)   (midx: 0)
	R1 <4> <- [R2]   (midx: 0)
	R0 <4> <- #_in_value   (midx: 0)
	R1 <4> <-  R0 + R1   (midx: 2)
	R0 <1> <- 0   (midx: 0)
	[R1] <1> <- R0   (midx: 0)
//main.c,150 :: 		for (in_value_index=0; in_value_index<MAX_KEY_IN_CHARS; in_value_index++)
	R0 <4> <- R2   (midx: 0)
	R0 <1> <- [R0]   (midx: 0)
	R0 <1> <-  R0 + 1   (midx: 0)
	[R2] <1> <- R0   (midx: 0)
//main.c,151 :: 		in_value[in_value_index] = 0;
	goto	34   (midx: 0)
35:   (midx: 0)
//main.c,152 :: 		in_value_index = 0;
	R1 <1> <- 0   (midx: 0)
	R0 <4> <- addr(_in_value_index)   (midx: 0)
	[R0] <1> <- R1   (midx: 0)
//main.c,153 :: 		break;    // this is the OK button
	goto	26   (midx: 0)
//main.c,155 :: 		case KEYCODE_UP:
37:   (midx: 0)
//main.c,156 :: 		bPrompt = 1;
	R1 <1> <- 1   (midx: 0)
	R0 <4> <- addr(_bPrompt)   (midx: 0)
	[R0] <0> <- R1   (midx: 0)
//main.c,157 :: 		if (in_value[in_value_index]<MAX_KEY_IN_TABLE-1) in_value[in_value_index]++;
	R0 <4> <- addr(_in_value_index)   (midx: 0)
	R1 <4> <- [R0]   (midx: 0)
	R0 <4> <- #_in_value   (midx: 0)
	R0 <4> <-  R0 + R1   (midx: 2)
	R0 <1> <- *R0   (midx: 0)
	if ( R0 >= 11) then goto 38   (midx: 0)
	R0 <4> <- addr(_in_value_index)   (midx: 0)
	R1 <4> <- [R0]   (midx: 0)
	R0 <4> <- #_in_value   (midx: 0)
	R1 <4> <-  R0 + R1   (midx: 2)
	R0 <1> <- *R1   (midx: 0)
	R0 <1> <-  R0 + 1   (midx: 0)
	[R1] <1> <- R0   (midx: 0)
	goto	39   (midx: 0)
38:   (midx: 0)
//main.c,158 :: 		else in_value[in_value_index] = 0;
	R0 <4> <- addr(_in_value_index)   (midx: 0)
	R1 <4> <- [R0]   (midx: 0)
	R0 <4> <- #_in_value   (midx: 0)
	R1 <4> <-  R0 + R1   (midx: 2)
	R0 <1> <- 0   (midx: 0)
	[R1] <1> <- R0   (midx: 0)
39:   (midx: 0)
//main.c,159 :: 		Display_Char(x_pos, y_pos, WHITE,PRN, val_tab[in_value[in_value_index]]);
	R0 <4> <- addr(_in_value_index)   (midx: 0)
	R1 <4> <- [R0]   (midx: 0)
	R0 <4> <- #_in_value   (midx: 0)
	R0 <4> <-  R0 + R1   (midx: 2)
	R1 <1> <- *R0   (midx: 0)
	R0 <4> <- #_val_tab   (midx: 0)
	R0 <4> <-  R0 + R1   (midx: 2)
	R0 <1> <- *R0   (midx: 0)
	R2 <1> <- R0   (midx: 0)
	R0 <4> <- addr(main_y_pos)   (midx: 0)
	R1 <2> <- [R0]   (midx: 0)
	R0 <4> <- addr(main_x_pos)   (midx: 0)
	R0 <2> <- [R0]   (midx: 0)
	FARG_Display_Char_s <1> <- PUSH(R2)   (midx: 0)
	R3 <1> <- 0   (midx: 0)
	R2 <2> <- 65535   (midx: 0)
	R1 <2> <- R1   (midx: 0)
	R0 <2> <- R0   (midx: 0)
	CALL _Display_Char   (midx: 0)
//main.c,160 :: 		break;
	goto	26   (midx: 0)
//main.c,162 :: 		case KEYCODE_DOWN:
40:   (midx: 0)
//main.c,163 :: 		bPrompt = 1;
	R1 <1> <- 1   (midx: 0)
	R0 <4> <- addr(_bPrompt)   (midx: 0)
	[R0] <0> <- R1   (midx: 0)
//main.c,164 :: 		if (in_value[in_value_index]>0) in_value[in_value_index]--;
	R0 <4> <- addr(_in_value_index)   (midx: 0)
	R1 <4> <- [R0]   (midx: 0)
	R0 <4> <- #_in_value   (midx: 0)
	R0 <4> <-  R0 + R1   (midx: 2)
	R0 <1> <- *R0   (midx: 0)
	if ( R0 <= 0) then goto 41   (midx: 0)
	R0 <4> <- addr(_in_value_index)   (midx: 0)
	R1 <4> <- [R0]   (midx: 0)
	R0 <4> <- #_in_value   (midx: 0)
	R1 <4> <-  R0 + R1   (midx: 2)
	R0 <1> <- *R1   (midx: 0)
	R0 <1> <-  R0 - 1   (midx: 0)
	[R1] <1> <- R0   (midx: 0)
	goto	42   (midx: 0)
41:   (midx: 0)
//main.c,165 :: 		else in_value[in_value_index] = MAX_KEY_IN_TABLE-1;
	R0 <4> <- addr(_in_value_index)   (midx: 0)
	R1 <4> <- [R0]   (midx: 0)
	R0 <4> <- #_in_value   (midx: 0)
	R1 <4> <-  R0 + R1   (midx: 2)
	R0 <1> <- 11   (midx: 0)
	[R1] <1> <- R0   (midx: 0)
42:   (midx: 0)
//main.c,166 :: 		Display_Char(x_pos, y_pos, WHITE,PRN, val_tab[in_value[in_value_index]]);
	R0 <4> <- addr(_in_value_index)   (midx: 0)
	R1 <4> <- [R0]   (midx: 0)
	R0 <4> <- #_in_value   (midx: 0)
	R0 <4> <-  R0 + R1   (midx: 2)
	R1 <1> <- *R0   (midx: 0)
	R0 <4> <- #_val_tab   (midx: 0)
	R0 <4> <-  R0 + R1   (midx: 2)
	R0 <1> <- *R0   (midx: 0)
	R2 <1> <- R0   (midx: 0)
	R0 <4> <- addr(main_y_pos)   (midx: 0)
	R1 <2> <- [R0]   (midx: 0)
	R0 <4> <- addr(main_x_pos)   (midx: 0)
	R0 <2> <- [R0]   (midx: 0)
	FARG_Display_Char_s <1> <- PUSH(R2)   (midx: 0)
	R3 <1> <- 0   (midx: 0)
	R2 <2> <- 65535   (midx: 0)
	R1 <2> <- R1   (midx: 0)
	R0 <2> <- R0   (midx: 0)
	CALL _Display_Char   (midx: 0)
//main.c,167 :: 		break;
	goto	26   (midx: 0)
//main.c,169 :: 		case KEYCODE_LEFT:
43:   (midx: 0)
//main.c,170 :: 		bPrompt = 1;
	R1 <1> <- 1   (midx: 0)
	R0 <4> <- addr(_bPrompt)   (midx: 0)
	[R0] <0> <- R1   (midx: 0)
//main.c,171 :: 		if (in_value_index>0){
	R0 <4> <- addr(_in_value_index)   (midx: 0)
	R0 <1> <- [R0]   (midx: 0)
	if ( R0 <= 0) then goto 44   (midx: 0)
//main.c,172 :: 		if (in_value[in_value_index] == 0){
	R0 <4> <- addr(_in_value_index)   (midx: 0)
	R1 <4> <- [R0]   (midx: 0)
	R0 <4> <- #_in_value   (midx: 0)
	R0 <4> <-  R0 + R1   (midx: 2)
	R0 <1> <- *R0   (midx: 0)
	if ( R0 != 0) then goto 45   (midx: 0)
//main.c,173 :: 		Display_Char(x_pos, y_pos, WHITE,PRN, ' ');
	R2 <1> <- 32   (midx: 0)
	R0 <4> <- addr(main_y_pos)   (midx: 0)
	R1 <2> <- [R0]   (midx: 0)
	R0 <4> <- addr(main_x_pos)   (midx: 0)
	R0 <2> <- [R0]   (midx: 0)
	FARG_Display_Char_s <1> <- PUSH(R2)   (midx: 0)
	R3 <1> <- 0   (midx: 0)
	R2 <2> <- 65535   (midx: 0)
	R1 <2> <- R1   (midx: 0)
	R0 <2> <- R0   (midx: 0)
	CALL _Display_Char   (midx: 0)
//main.c,174 :: 		} else {
	goto	46   (midx: 0)
45:   (midx: 0)
//main.c,175 :: 		Display_Char(x_pos, y_pos, WHITE,PRN, val_tab[in_value[in_value_index]]);
	R0 <4> <- addr(_in_value_index)   (midx: 0)
	R1 <4> <- [R0]   (midx: 0)
	R0 <4> <- #_in_value   (midx: 0)
	R0 <4> <-  R0 + R1   (midx: 2)
	R1 <1> <- *R0   (midx: 0)
	R0 <4> <- #_val_tab   (midx: 0)
	R0 <4> <-  R0 + R1   (midx: 2)
	R0 <1> <- *R0   (midx: 0)
	R2 <1> <- R0   (midx: 0)
	R0 <4> <- addr(main_y_pos)   (midx: 0)
	R1 <2> <- [R0]   (midx: 0)
	R0 <4> <- addr(main_x_pos)   (midx: 0)
	R0 <2> <- [R0]   (midx: 0)
	FARG_Display_Char_s <1> <- PUSH(R2)   (midx: 0)
	R3 <1> <- 0   (midx: 0)
	R2 <2> <- 65535   (midx: 0)
	R1 <2> <- R1   (midx: 0)
	R0 <2> <- R0   (midx: 0)
	CALL _Display_Char   (midx: 0)
//main.c,176 :: 		}
46:   (midx: 0)
//main.c,177 :: 		in_value_index--;
	R1 <4> <- addr(_in_value_index)   (midx: 0)
	R0 <1> <- [R1]   (midx: 0)
	R2 <1> <-  R0 - 1   (midx: 0)
	[R1] <1> <- R2   (midx: 0)
//main.c,178 :: 		x_pos-=STEP_X_POS;
	R1 <4> <- addr(main_x_pos)   (midx: 0)
	R0 <2> <- [R1]   (midx: 0)
	R3 <2> <-  R0 - 9   (midx: 5)
	[R1] <2> <- R3   (midx: 0)
//main.c,179 :: 		Display_Char(x_pos, y_pos, WHITE,PRN, val_tab[in_value[in_value_index]]);
	R0 <4> <- #_in_value   (midx: 0)
	R0 <4> <-  R0 + R2   (midx: 2)
	R1 <1> <- *R0   (midx: 0)
	R0 <4> <- #_val_tab   (midx: 0)
	R0 <4> <-  R0 + R1   (midx: 2)
	R0 <1> <- *R0   (midx: 0)
	R2 <1> <- R0   (midx: 0)
	R0 <4> <- addr(main_y_pos)   (midx: 0)
	R1 <2> <- [R0]   (midx: 0)
	R0 <2> <- R3   (midx: 0)
	FARG_Display_Char_s <1> <- PUSH(R2)   (midx: 0)
	R3 <1> <- 0   (midx: 0)
	R2 <2> <- 65535   (midx: 0)
	R1 <2> <- R1   (midx: 0)
	R0 <2> <- R0   (midx: 0)
	CALL _Display_Char   (midx: 0)
//main.c,180 :: 		}
44:   (midx: 0)
//main.c,181 :: 		break;
	goto	26   (midx: 0)
//main.c,183 :: 		case KEYCODE_RIGHT:
47:   (midx: 0)
//main.c,184 :: 		bPrompt = 1;
	R1 <1> <- 1   (midx: 0)
	R0 <4> <- addr(_bPrompt)   (midx: 0)
	[R0] <0> <- R1   (midx: 0)
//main.c,185 :: 		if (in_value[in_value_index] == 0) in_value[in_value_index] = 1;
	R0 <4> <- addr(_in_value_index)   (midx: 0)
	R1 <4> <- [R0]   (midx: 0)
	R0 <4> <- #_in_value   (midx: 0)
	R0 <4> <-  R0 + R1   (midx: 2)
	R0 <1> <- *R0   (midx: 0)
	if ( R0 != 0) then goto 48   (midx: 0)
	R0 <4> <- addr(_in_value_index)   (midx: 0)
	R1 <4> <- [R0]   (midx: 0)
	R0 <4> <- #_in_value   (midx: 0)
	R1 <4> <-  R0 + R1   (midx: 2)
	R0 <1> <- 1   (midx: 0)
	[R1] <1> <- R0   (midx: 0)
48:   (midx: 0)
//main.c,186 :: 		if (in_value_index<MAX_KEY_IN_CHARS){
	R0 <4> <- addr(_in_value_index)   (midx: 0)
	R0 <1> <- [R0]   (midx: 0)
	if ( R0 >= 8) then goto 49   (midx: 0)
//main.c,187 :: 		Display_Char(x_pos, y_pos, WHITE,PRN, val_tab[in_value[in_value_index]]);
	R0 <4> <- addr(_in_value_index)   (midx: 0)
	R1 <4> <- [R0]   (midx: 0)
	R0 <4> <- #_in_value   (midx: 0)
	R0 <4> <-  R0 + R1   (midx: 2)
	R1 <1> <- *R0   (midx: 0)
	R0 <4> <- #_val_tab   (midx: 0)
	R0 <4> <-  R0 + R1   (midx: 2)
	R0 <1> <- *R0   (midx: 0)
	R2 <1> <- R0   (midx: 0)
	R0 <4> <- addr(main_y_pos)   (midx: 0)
	FLOC_HandleKeyPress+4 <4> <- R0   (midx: 0)
	R1 <2> <- [R0]   (midx: 0)
	R0 <4> <- addr(main_x_pos)   (midx: 0)
	FLOC_HandleKeyPress+0 <4> <- R0   (midx: 0)
	R0 <2> <- [R0]   (midx: 0)
	FARG_Display_Char_s <1> <- PUSH(R2)   (midx: 0)
	R3 <1> <- 0   (midx: 0)
	R2 <2> <- 65535   (midx: 0)
	R1 <2> <- R1   (midx: 0)
	R0 <2> <- R0   (midx: 0)
	CALL _Display_Char   (midx: 0)
//main.c,188 :: 		in_value_index++;
	R1 <4> <- addr(_in_value_index)   (midx: 0)
	R0 <1> <- [R1]   (midx: 0)
	R2 <1> <-  R0 + 1   (midx: 0)
	[R1] <1> <- R2   (midx: 0)
//main.c,189 :: 		x_pos+=STEP_X_POS;
	R1 <4> <- FLOC_HandleKeyPress+0   (midx: 0)
	R0 <4> <- R1   (midx: 0)
	R0 <2> <- [R0]   (midx: 0)
	R3 <2> <-  R0 + 9   (midx: 5)
	[R1] <2> <- R3   (midx: 0)
//main.c,190 :: 		Display_Char(x_pos, y_pos, WHITE,PRN, val_tab[in_value[in_value_index]]);
	R0 <4> <- #_in_value   (midx: 0)
	R0 <4> <-  R0 + R2   (midx: 2)
	R1 <1> <- *R0   (midx: 0)
	R0 <4> <- #_val_tab   (midx: 0)
	R0 <4> <-  R0 + R1   (midx: 2)
	R0 <1> <- *R0   (midx: 0)
	R2 <1> <- R0   (midx: 0)
	R0 <4> <- FLOC_HandleKeyPress+4   (midx: 0)
	R0 <4> <- R0   (midx: 0)
	R1 <2> <- [R0]   (midx: 0)
	R0 <2> <- R3   (midx: 0)
	FARG_Display_Char_s <1> <- PUSH(R2)   (midx: 0)
	R3 <1> <- 0   (midx: 0)
	R2 <2> <- 65535   (midx: 0)
	R1 <2> <- R1   (midx: 0)
	R0 <2> <- R0   (midx: 0)
	CALL _Display_Char   (midx: 0)
//main.c,191 :: 		}
49:   (midx: 0)
//main.c,192 :: 		break;
	goto	26   (midx: 0)
//main.c,193 :: 		}
25:   (midx: 0)
	R0 <4> <- addr(main_cur_key_press)   (midx: 0)
	R0 <1> <- [R0]   (midx: 0)
	if ( R0 = 0) then goto 27   (midx: 0)
	R0 <4> <- addr(main_cur_key_press)   (midx: 0)
	R0 <1> <- [R0]   (midx: 0)
	if ( R0 = 1) then goto 32   (midx: 0)
	R0 <4> <- addr(main_cur_key_press)   (midx: 0)
	R0 <1> <- [R0]   (midx: 0)
	if ( R0 = 2) then goto 33   (midx: 0)
	R0 <4> <- addr(main_cur_key_press)   (midx: 0)
	R0 <1> <- [R0]   (midx: 0)
	if ( R0 = 3) then goto 37   (midx: 0)
	R0 <4> <- addr(main_cur_key_press)   (midx: 0)
	R0 <1> <- [R0]   (midx: 0)
	if ( R0 = 4) then goto 40   (midx: 0)
	R0 <4> <- addr(main_cur_key_press)   (midx: 0)
	R0 <1> <- [R0]   (midx: 0)
	if ( R0 = 5) then goto 43   (midx: 0)
	R0 <4> <- addr(main_cur_key_press)   (midx: 0)
	R0 <1> <- [R0]   (midx: 0)
	if ( R0 = 6) then goto 47   (midx: 0)
26:   (midx: 0)
  end
   (midx: 0)
_main:
  begin   (midx: 0)
//main.c,198 :: 		void main(void)
_main:
  begin   (midx: 0)
//main.c,202 :: 		Delay_ms(200);
	asm: -1   (midx: 1)
	asm: -1   (midx: 1)
	asm: -1   (midx: 1)
	asm: -1   (midx: 1)
	asm: -1   (midx: 2)
	asm: -1   (midx: 1)
	asm: -1   (midx: 5)
	asm: -1   (midx: 1)
	asm: -1   (midx: 1)
	asm: -1   (midx: 1)
	asm: -1   (midx: 1)
//main.c,203 :: 		GPIO_Configure();
	CALL _GPIO_Configure   (midx: 0)
//main.c,204 :: 		InitUART1();
	CALL _InitUART1   (midx: 0)
//main.c,205 :: 		InitTimers();
	CALL _InitTimers   (midx: 0)
//main.c,206 :: 		LCD_Initial();
	CALL _LCD_Initial   (midx: 0)
//main.c,207 :: 		Clear_Screen(BLACK);
	R0 <2> <- 0   (midx: 0)
	CALL _Clear_Screen   (midx: 0)
//main.c,208 :: 		Display_Str(2, 2, WHITE,PRN, "Terminal rev 1.0");
	R0 <4> <- #?lstr_1_main   (midx: 0)
	FARG_Display_Str_s <4> <- PUSH(R0)   (midx: 0)
	R3 <1> <- 0   (midx: 0)
	R2 <2> <- 65535   (midx: 0)
	R1 <2> <- 2   (midx: 0)
	R0 <2> <- 2   (midx: 0)
	CALL _Display_Str   (midx: 0)
//main.c,209 :: 		Delay_ms(2000);
	asm: -1   (midx: 1)
	asm: -1   (midx: 1)
	asm: -1   (midx: 1)
	asm: -1   (midx: 1)
	asm: -1   (midx: 2)
	asm: -1   (midx: 1)
	asm: -1   (midx: 5)
	asm: -1   (midx: 1)
	asm: -1   (midx: 1)
	asm: -1   (midx: 1)
	asm: -1   (midx: 1)
//main.c,210 :: 		Clear_Screen(BLACK);
	R0 <2> <- 0   (midx: 0)
	CALL _Clear_Screen   (midx: 0)
//main.c,212 :: 		while (1){
52:   (midx: 0)
//main.c,213 :: 		Handle_UART_Input();
	CALL _Handle_UART_Input   (midx: 0)
//main.c,214 :: 		if (b20ms){
	R1 <4> <- addr(_b20ms)   (midx: 0)
	R0 <4> <- [R1]   (midx: 0)
	if (!R0) then goto 54   (midx: 0)
//main.c,215 :: 		b20ms = 0;
	R1 <1> <- 0   (midx: 0)
	R0 <4> <- addr(_b20ms)   (midx: 0)
	[R0] <0> <- R1   (midx: 0)
//main.c,216 :: 		HandleKeyPress();
	CALL _HandleKeyPress   (midx: 0)
//main.c,217 :: 		}
54:   (midx: 0)
//main.c,218 :: 		}
	goto	52   (midx: 0)
  end
   (midx: 0)
_Timer2_interrupt:
  begin   (midx: 0)
//main.c,225 :: 		void Timer2_interrupt() iv IVT_INT_TIM2
_Timer2_interrupt:
  begin   (midx: 0)
//main.c,229 :: 		TIM2_SR.UIF = 0;
	R1 <1> <- 0   (midx: 0)
	R0 <4> <- addr(TIM2_SR)   (midx: 0)
	[R0] <0> <- R1   (midx: 20)
//main.c,230 :: 		b1ms = 1;
	R1 <1> <- 1   (midx: 0)
	R0 <4> <- addr(_b1ms)   (midx: 0)
	[R0] <0> <- R1   (midx: 0)
//main.c,232 :: 		if (count20<20) count20++;
	R0 <4> <- addr(Timer2_interrupt_count20_L0)   (midx: 0)
	R0 <1> <- [R0]   (midx: 0)
	if ( R0 >= 20) then goto 55   (midx: 4)
	R1 <4> <- addr(Timer2_interrupt_count20_L0)   (midx: 0)
	R0 <1> <- [R1]   (midx: 0)
	R0 <1> <-  R0 + 1   (midx: 0)
	[R1] <1> <- R0   (midx: 0)
	goto	56   (midx: 0)
55:   (midx: 0)
//main.c,234 :: 		count20 = 0;
	R1 <1> <- 0   (midx: 0)
	R0 <4> <- addr(Timer2_interrupt_count20_L0)   (midx: 0)
	[R0] <1> <- R1   (midx: 0)
//main.c,235 :: 		b20ms = 1;
	R1 <1> <- 1   (midx: 0)
	R0 <4> <- addr(_b20ms)   (midx: 0)
	[R0] <0> <- R1   (midx: 0)
//main.c,236 :: 		}
56:   (midx: 0)
  end
   (midx: 0)
_Usart1_ISR:
  begin   (midx: 0)
//main.c,239 :: 		void Usart1_ISR() iv IVT_INT_USART1 ics ICS_AUTO
_Usart1_ISR:
  begin   (midx: 0)
//main.c,241 :: 		if (TXE_USART1_SR_bit == 1 && TXEIE_USART1_CR1_bit == 1){     // make sure the high speed modem is ready to transmit
	R1 <4> <- addr(TXE_USART1_SR_bit)   (midx: 0)
	R0 <4> <- [R1]   (midx: 0)
	if (!R0) then goto 69   (midx: 21)
	R1 <4> <- addr(TXEIE_USART1_CR1_bit)   (midx: 0)
	R0 <4> <- [R1]   (midx: 0)
	if (!R0) then goto 68   (midx: 21)
67:   (midx: 0)
//main.c,242 :: 		USART1_SR = 0;
	R1 <4> <- 0   (midx: 0)
	R0 <4> <- addr(USART1_SR)   (midx: 0)
	[R0] <4> <- R1   (midx: 0)
//main.c,243 :: 		USART1_DR = 0;
	R1 <4> <- 0   (midx: 0)
	R0 <4> <- addr(USART1_DR)   (midx: 0)
	[R0] <4> <- R1   (midx: 0)
//main.c,244 :: 		} else if (RXNE_USART1_SR_bit == 1 && RXNEIE_USART1_CR1_bit == 1){
	goto	60   (midx: 0)
//main.c,241 :: 		if (TXE_USART1_SR_bit == 1 && TXEIE_USART1_CR1_bit == 1){     // make sure the high speed modem is ready to transmit
69:   (midx: 0)
68:   (midx: 0)
//main.c,244 :: 		} else if (RXNE_USART1_SR_bit == 1 && RXNEIE_USART1_CR1_bit == 1){
	R1 <4> <- addr(RXNE_USART1_SR_bit)   (midx: 0)
	R0 <4> <- [R1]   (midx: 0)
	if (!R0) then goto 71   (midx: 21)
	R1 <4> <- addr(RXNEIE_USART1_CR1_bit)   (midx: 0)
	R0 <4> <- [R1]   (midx: 0)
	if (!R0) then goto 70   (midx: 21)
66:   (midx: 0)
//main.c,245 :: 		in_buffer[in_ptr++] = (char)((unsigned int)(USART1_DR & (unsigned int)0x00ff));
	R2 <4> <- addr(main_in_ptr)   (midx: 0)
	R1 <4> <- [R2]   (midx: 0)
	R0 <4> <- #main_in_buffer   (midx: 0)
	R1 <4> <-  R0 + R1   (midx: 2)
	R0 <4> <- addr(USART1_DR)   (midx: 0)
	R0 <4> <- [R0]   (midx: 0)
	R0 <4> <-  R0 & 255   (midx: 2)
	R0 <1> <- R0   (midx: 0)
	[R1] <1> <- R0   (midx: 0)
	R0 <4> <- R2   (midx: 0)
	R0 <2> <- [R0]   (midx: 0)
	R0 <2> <-  R0 + 1   (midx: 1)
	[R2] <2> <- R0   (midx: 0)
//main.c,246 :: 		if (in_ptr>=MAX_IN_BUFFER) in_ptr = 0;
	if ( R0 < 128) then goto 64   (midx: 1)
	R1 <2> <- 0   (midx: 0)
	R0 <4> <- addr(main_in_ptr)   (midx: 0)
	[R0] <2> <- R1   (midx: 0)
64:   (midx: 0)
//main.c,244 :: 		} else if (RXNE_USART1_SR_bit == 1 && RXNEIE_USART1_CR1_bit == 1){
71:   (midx: 0)
70:   (midx: 0)
//main.c,247 :: 		}
60:   (midx: 0)
  end
   (midx: 0)
